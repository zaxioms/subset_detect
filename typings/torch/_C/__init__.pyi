"""
This type stub file was generated by pyright.
"""

import torch
import builtins
from torch import Tensor
from enum import Enum
from pathlib import Path
from typing import Any, AnyStr, BinaryIO, Callable, ContextManager, Dict, Generic, Iterator, List, NamedTuple, Optional, Sequence, Set, Tuple, Type, TypeVar, Union, overload
from torch._six import inf
from torch.types import Device, Number, Storage, _bool, _device, _dtype, _float, _int, _layout, _qscheme, _size
from . import _VariableFunctions as _VariableFunctions, _nn as _nn, _onnx as _onnx

"""
This type stub file was generated by pyright.
"""
T = TypeVar('T')
class device:
    type: str
    index: _int
    @overload
    def __init__(self, device: Union[_device, _int, str]) -> None:
        ...
    
    @overload
    def __init__(self, type: str, index: _int) -> None:
        ...
    
    def __reduce__(self) -> Tuple[Any, ...]:
        ...
    


class Size(Tuple[_int, ...]):
    @overload
    def __getitem__(self: Size, key: _int) -> _int:
        ...
    
    @overload
    def __getitem__(self: Size, key: slice) -> Size:
        ...
    
    def numel(self: Size) -> _int:
        ...
    


class dtype:
    is_floating_point: _bool
    is_complex: _bool
    is_signed: _bool
    ...


class iinfo:
    bits: _int
    min: _int
    max: _int
    dtype: str
    def __init__(self, dtype: _dtype) -> None:
        ...
    


class finfo:
    bits: _float
    min: _float
    max: _float
    eps: _float
    tiny: _float
    resolution: _float
    dtype: str
    @overload
    def __init__(self, dtype: _dtype) -> None:
        ...
    
    @overload
    def __init__(self) -> None:
        ...
    


float32: dtype = ...
float: dtype = ...
float64: dtype = ...
double: dtype = ...
float16: dtype = ...
bfloat16: dtype = ...
half: dtype = ...
uint8: dtype = ...
int8: dtype = ...
int16: dtype = ...
short: dtype = ...
int32: dtype = ...
int: dtype = ...
int64: dtype = ...
long: dtype = ...
complex32: dtype = ...
complex64: dtype = ...
cfloat: dtype = ...
complex128: dtype = ...
cdouble: dtype = ...
quint8: dtype = ...
qint8: dtype = ...
qint32: dtype = ...
bool: dtype = ...
class layout:
    ...


def DisableTorchFunction():
    ...

strided: layout = ...
sparse_coo: layout = ...
_mkldnn: layout = ...
class memory_format:
    ...


contiguous_format: memory_format = ...
channels_last: memory_format = ...
channels_last_3d: memory_format = ...
preserve_format: memory_format = ...
class qscheme:
    ...


per_tensor_affine: qscheme = ...
per_channel_affine: qscheme = ...
per_tensor_symmetric: qscheme = ...
per_channel_symmetric: qscheme = ...
per_channel_affine_float_qparams: qscheme = ...
class _FunctionBase(object):
    ...


class _LegacyVariableBase(object):
    def __init__(self, data: Optional[Tensor] = ..., requires_grad: Optional[_bool] = ..., volatile: Optional[_bool] = ..., _grad_fn: Optional[_FunctionBase] = ...) -> None:
        ...
    


class IODescriptor:
    ...


class JITException:
    ...


class Future(object):
    def __init__(self) -> None:
        ...
    
    def done(self) -> _bool:
        ...
    
    def wait(self) -> Any:
        ...
    
    def then(self, callback: Callable) -> Future:
        ...
    
    def set_result(self, result: Any) -> None:
        ...
    


class MobileOptimizerType:
    ...


CONV_BN_FUSION: MobileOptimizerType
INSERT_FOLD_PREPACK_OPS: MobileOptimizerType
REMOVE_DROPOUT: MobileOptimizerType
FUSE_ADD_RELU: MobileOptimizerType
HOIST_CONV_PACKED_PARAMS: MobileOptimizerType
def fork(*args: Any, **kwargs: Any) -> Future:
    ...

def wait(fut: Future) -> Any:
    ...

def unify_type_list(types: List[JitType]) -> JitType:
    ...

ResolutionCallback = Callable[[str], Callable[..., Any]]
def parse_type_comment(comment: str) -> Decl:
    ...

def merge_type_from_type_comment(decl: Decl, type_annotation_decl: Decl, is_method: _bool) -> Decl:
    ...

def import_ir_module(cu: CompilationUnit, filename: Union[str, Path], map_location: Union[_device, str, None], extra_files: Dict[str, Any]) -> ScriptModule:
    ...

def import_ir_module_from_buffer(cu: CompilationUnit, buffer: BinaryIO, map_location: Union[_device, str, None], extra_files: Dict[str, Any]) -> ScriptModule:
    ...

class Graph:
    ...


class Value:
    ...


class FunctionSchema:
    ...


class ConcreteModuleTypeBuilder:
    def __init__(self, obj: Any) -> None:
        ...
    
    def set_module_dict(self):
        ...
    
    def set_module_list(self):
        ...
    
    def add_attribute(self, name: str, ty: JitType, is_param: _bool, is_buffer: _bool):
        ...
    
    def add_module(self, name: str, meta: ConcreteModuleType):
        ...
    
    def add_constant(self, name: str, value: Any):
        ...
    
    def add_overload(self, method_name: str, overloaded_method_names: List[str]):
        ...
    
    def add_builtin_function(self, name: str, symbol_name: str):
        ...
    
    def add_failed_attribute(self, name: str, failure_reason: str):
        ...
    
    def add_function_attribute(self, name: str, ty: JitType, func: Callable[..., Any]):
        ...
    


class ConcreteModuleType:
    def get_constants(self) -> Dict[str, Any]:
        ...
    
    def equals(self, other: ConcreteModuleType) -> _bool:
        ...
    
    @staticmethod
    def from_jit_type(ty: JitType) -> ConcreteModuleType:
        ...
    


class CallStack:
    def __init__(self, name: str, range: SourceRange) -> None:
        ...
    


class ErrorReport:
    def __init__(self, range: SourceRange) -> None:
        ...
    
    def what(self) -> str:
        ...
    
    @staticmethod
    def call_stack() -> str:
        ...
    


class CompilationUnit:
    def __init__(self) -> None:
        ...
    
    def find_function(self, name: str) -> ScriptFunction:
        ...
    
    def define(self, script: str, rcb: ResolutionCallback):
        ...
    


class ScriptModule:
    def setattr(self, name: str, value: Any):
        ...
    


class ScriptFunction:
    def __call__(self, *args, **kwargs) -> Tensor:
        ...
    
    def save(self, filename: str, _extra_files: Dict[str, bytes]) -> None:
        ...
    
    def save_to_buffer(self, _extra_files: Dict[str, bytes]) -> bytes:
        ...
    
    def graph(self) -> Graph:
        ...
    
    def inlined_graph(self) -> Graph:
        ...
    
    def schema(self) -> FunctionSchema:
        ...
    
    def code(self) -> str:
        ...
    
    def name(self) -> str:
        ...
    
    @property
    def qualified_name(self) -> str:
        ...
    


class ScriptMethod:
    ...


class ModuleDict:
    def __init__(self, mod: ScriptModule) -> None:
        ...
    
    def items(self) -> List[Tuple[str, Any]]:
        ...
    


class ParameterDict:
    def __init__(self, mod: ScriptModule) -> None:
        ...
    


class BufferDict:
    def __init__(self, mod: ScriptModule) -> None:
        ...
    


def get_num_thread() -> _int:
    ...

def set_num_threads(nthreads: _int) -> None:
    ...

def get_num_interop_threads() -> _int:
    ...

def set_num_interop_threads(nthreads: _int) -> None:
    ...

def set_flush_denormal(arg: _bool) -> _bool:
    ...

def get_default_dtype() -> _dtype:
    ...

has_openmp: _bool
has_mkl: _bool
has_lapack: _bool
has_cuda: _bool
has_mkldnn: _bool
has_cudnn: _bool
_GLIBCXX_USE_CXX11_ABI: _bool
default_generator: Generator
def is_grad_enabled() -> _bool:
    ...

def set_autocast_enabled(enabled: _bool) -> None:
    ...

def is_autocast_enabled() -> _bool:
    ...

def clear_autocast_cache() -> None:
    ...

def autocast_increment_nesting() -> _int:
    ...

def autocast_decrement_nesting() -> _int:
    ...

def set_anomaly_enabled(enabled: _bool) -> None:
    ...

def is_anomaly_enabled() -> _bool:
    ...

class LoggerBase(object):
    ...


class NoopLogger(LoggerBase):
    ...


class LockingLogger(LoggerBase):
    ...


class AggregationType(Enum):
    SUM = ...
    AVG = ...


class FileCheck(object):
    def check_source_highlighted(self, highlight: str) -> FileCheck:
        ...
    
    def run(self, test_string: str) -> None:
        ...
    


class PyTorchFileReader(object):
    @overload
    def __init__(self, name: str) -> None:
        ...
    
    @overload
    def __init__(self, buffer: BinaryIO) -> None:
        ...
    
    def get_record(self, name: str) -> bytes:
        ...
    


class PyTorchFileWriter(object):
    @overload
    def __init__(self, name: str) -> None:
        ...
    
    @overload
    def __init__(self, buffer: BinaryIO) -> None:
        ...
    
    def write_record(self, name: str, data: bytes, size: _int) -> None:
        ...
    
    def write_end_of_file(self) -> None:
        ...
    


class Generator(object):
    device: _device
    def __init__(self, device: Union[_device, str, None] = ...) -> None:
        ...
    
    def get_state(self) -> Tensor:
        ...
    
    def set_state(self, _new_state: Tensor) -> Generator:
        ...
    
    def manual_seed(self, seed: _int) -> Generator:
        ...
    
    def seed(self) -> _int:
        ...
    
    def initial_seed(self) -> _int:
        ...
    


class BenchmarkConfig(object):
    num_calling_threads: _int
    num_worker_threads: _int
    num_warmup_iters: _int
    num_iters: _int
    profiler_output_path: str
    ...


class BenchmarkExecutionStats(object):
    latency_avg_ms: _float
    num_iters: _int
    ...


class ThroughputBenchmark(object):
    def __init__(self, module: Any) -> None:
        ...
    
    def add_input(self, *args: Any, **kwargs: Any) -> None:
        ...
    
    def run_once(self, *args: Any, **kwargs: Any) -> Any:
        ...
    
    def benchmark(self, config: BenchmarkConfig) -> BenchmarkExecutionStats:
        ...
    


namedtuple_values_indices = NamedTuple("namedtuple_values_indices", [("values", Tensor), ("indices", Tensor)])
namedtuple_eigenvalues_eigenvectors = NamedTuple("namedtuple_eigenvalues_eigenvectors", [("eigenvalues", Tensor), ("eigenvectors", Tensor)])
namedtuple_a_tau = NamedTuple("namedtuple_a_tau", [("a", Tensor), ("tau", Tensor)])
namedtuple_solution_QR = NamedTuple("namedtuple_solution_QR", [("solution", Tensor), ("QR", Tensor)])
namedtuple_Q_R = NamedTuple("namedtuple_Q_R", [("Q", Tensor), ("R", Tensor)])
namedtuple_sign_logabsdet = NamedTuple("namedtuple_sign_logabsdet", [("sign", Tensor), ("logabsdet", Tensor)])
namedtuple_solution_LU = NamedTuple("namedtuple_solution_LU", [("solution", Tensor), ("LU", Tensor)])
namedtuple_U_S_V = NamedTuple("namedtuple_U_S_V", [("U", Tensor), ("S", Tensor), ("V", Tensor)])
namedtuple_solution_cloned_coefficient = NamedTuple("namedtuple_solution_cloned_coefficient", [("solution", Tensor), ("cloned_coefficient", Tensor)])
class DoubleStorageBase(object):
    ...


class FloatStorageBase(object):
    ...


class LongStorageBase(object):
    ...


class IntStorageBase(object):
    ...


class ShortStorageBase(object):
    ...


class CharStorageBase(object):
    ...


class ByteStorageBase(object):
    ...


class BoolStorageBase(object):
    ...


class HalfStorageBase(object):
    ...


class BFloat16StorageBase(object):
    ...


class ComplexDoubleStorageBase(object):
    ...


class ComplexFloatStorageBase(object):
    ...


class QUInt8StorageBase(object):
    ...


class QInt8StorageBase(object):
    ...


class QInt32StorageBase(object):
    ...


class DoubleTensor(Tensor):
    ...


class FloatTensor(Tensor):
    ...


class LongTensor(Tensor):
    ...


class IntTensor(Tensor):
    ...


class ShortTensor(Tensor):
    ...


class HalfTensor(Tensor):
    ...


class CharTensor(Tensor):
    ...


class ByteTensor(Tensor):
    ...


class BoolTensor(Tensor):
    ...


class _ImperativeEngine:
    ...


class _TensorBase(object):
    requires_grad: _bool
    shape: Size
    data: Tensor
    names: List[str]
    device: _device
    dtype: _dtype
    layout: _layout
    real: Tensor
    imag: Tensor
    T: Tensor
    ndim: _int
    _version: _int
    _base: Optional[Tensor]
    grad_fn: Any
    def __abs__(self) -> Tensor:
        ...
    
    def __add__(self, other: Any) -> Tensor:
        ...
    
    @overload
    def __and__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __and__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __and__(self, other: Any) -> Tensor:
        ...
    
    def __bool__(self) -> builtins.bool:
        ...
    
    def __complex__(self) -> builtins.complex:
        ...
    
    def __div__(self, other: Any) -> Tensor:
        ...
    
    def __eq__(self, other: Any) -> Tensor:
        ...
    
    def __float__(self) -> builtins.float:
        ...
    
    def __floordiv__(self, other: Any) -> Tensor:
        ...
    
    def __ge__(self, other: Any) -> Tensor:
        ...
    
    def __getitem__(self, indices: Union[None, _int, slice, Tensor, List, Tuple]) -> Tensor:
        ...
    
    def __gt__(self, other: Any) -> Tensor:
        ...
    
    def __iadd__(self, other: Any) -> Tensor:
        ...
    
    @overload
    def __iand__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __iand__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __iand__(self, other: Any) -> Tensor:
        ...
    
    def __idiv__(self, other: Any) -> Tensor:
        ...
    
    @overload
    def __ilshift__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __ilshift__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __ilshift__(self, other: Any) -> Tensor:
        ...
    
    def __imul__(self, other: Any) -> Tensor:
        ...
    
    def __index__(self) -> builtins.int:
        ...
    
    @overload
    def __init__(self, *args: Any, device: Union[_device, str, None] = ...) -> None:
        ...
    
    @overload
    def __init__(self, storage: Storage) -> None:
        ...
    
    @overload
    def __init__(self, other: Tensor) -> None:
        ...
    
    @overload
    def __init__(self, size: _size, *, device: Union[_device, str, None] = ...) -> None:
        ...
    
    def __int__(self) -> builtins.int:
        ...
    
    def __invert__(self) -> Tensor:
        ...
    
    @overload
    def __ior__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __ior__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __ior__(self, other: Any) -> Tensor:
        ...
    
    @overload
    def __irshift__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __irshift__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __irshift__(self, other: Any) -> Tensor:
        ...
    
    def __isub__(self, other: Any) -> Tensor:
        ...
    
    @overload
    def __ixor__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __ixor__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __ixor__(self, other: Any) -> Tensor:
        ...
    
    def __le__(self, other: Any) -> Tensor:
        ...
    
    def __long__(self) -> builtins.int:
        ...
    
    @overload
    def __lshift__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __lshift__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __lshift__(self, other: Any) -> Tensor:
        ...
    
    def __lt__(self, other: Any) -> Tensor:
        ...
    
    def __matmul__(self, other: Any) -> Tensor:
        ...
    
    def __mod__(self, other: Any) -> Tensor:
        ...
    
    def __mul__(self, other: Any) -> Tensor:
        ...
    
    def __ne__(self, other: Any) -> Tensor:
        ...
    
    def __neg__(self) -> Tensor:
        ...
    
    def __nonzero__(self) -> builtins.bool:
        ...
    
    @overload
    def __or__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __or__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __or__(self, other: Any) -> Tensor:
        ...
    
    def __pow__(self, other: Any) -> Tensor:
        ...
    
    def __radd__(self, other: Any) -> Tensor:
        ...
    
    def __rfloordiv__(self, other: Any) -> Tensor:
        ...
    
    def __rmul__(self, other: Any) -> Tensor:
        ...
    
    def __rpow__(self, other: Any) -> Tensor:
        ...
    
    @overload
    def __rshift__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __rshift__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __rshift__(self, other: Any) -> Tensor:
        ...
    
    def __rsub__(self, other: Any) -> Tensor:
        ...
    
    def __rtruediv__(self, other: Any) -> Tensor:
        ...
    
    def __setitem__(self, indices: Union[None, _int, slice, Tensor, List, Tuple], val: Union[Tensor, Number]) -> None:
        ...
    
    def __sub__(self, other: Any) -> Tensor:
        ...
    
    def __truediv__(self, other: Any) -> Tensor:
        ...
    
    @overload
    def __xor__(self, other: Number) -> Tensor:
        ...
    
    @overload
    def __xor__(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def __xor__(self, other: Any) -> Tensor:
        ...
    
    def abs(self) -> Tensor:
        ...
    
    def abs_(self) -> Tensor:
        ...
    
    def absolute(self) -> Tensor:
        ...
    
    def absolute_(self) -> Tensor:
        ...
    
    def acos(self) -> Tensor:
        ...
    
    def acos_(self) -> Tensor:
        ...
    
    def acosh(self) -> Tensor:
        ...
    
    def acosh_(self) -> Tensor:
        ...
    
    def add(self, other: Union[Tensor, Number], *, alpha: Optional[Number] = ..., out: Optional[Tensor] = ...) -> Tensor:
        ...
    
    def add_(self, other: Union[Tensor, Number], *, alpha: Optional[Number] = ...) -> Tensor:
        ...
    
    def addbmm(self, batch1: Tensor, batch2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def addbmm_(self, batch1: Tensor, batch2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def addcdiv(self, tensor1: Tensor, tensor2: Tensor, *, value: Number = ...) -> Tensor:
        ...
    
    def addcdiv_(self, tensor1: Tensor, tensor2: Tensor, *, value: Number = ...) -> Tensor:
        ...
    
    def addcmul(self, tensor1: Tensor, tensor2: Tensor, *, value: Number = ...) -> Tensor:
        ...
    
    def addcmul_(self, tensor1: Tensor, tensor2: Tensor, *, value: Number = ...) -> Tensor:
        ...
    
    def addmm(self, mat1: Tensor, mat2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def addmm_(self, mat1: Tensor, mat2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def addmv(self, mat: Tensor, vec: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def addmv_(self, mat: Tensor, vec: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def addr(self, vec1: Tensor, vec2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def addr_(self, vec1: Tensor, vec2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def align_as(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def align_to(self, names: Sequence[Union[str, ellipsis, None]]) -> Tensor:
        ...
    
    @overload
    def align_to(self, order: Sequence[Union[str, ellipsis, None]], ellipsis_idx: _int) -> Tensor:
        ...
    
    @overload
    def all(self, dim: _int, keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def all(self, dim: Union[str, ellipsis, None], keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def all(self) -> Tensor:
        ...
    
    def allclose(self, other: Tensor, rtol: _float = ..., atol: _float = ..., equal_nan: _bool = ...) -> _bool:
        ...
    
    def amax(self, dim: Union[_int, _size] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    def amin(self, dim: Union[_int, _size] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    def angle(self) -> Tensor:
        ...
    
    @overload
    def any(self, dim: _int, keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def any(self, dim: Union[str, ellipsis, None], keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def any(self) -> Tensor:
        ...
    
    def apply_(self, callable: Callable) -> Tensor:
        ...
    
    def arccos(self) -> Tensor:
        ...
    
    def arccos_(self) -> Tensor:
        ...
    
    def arccosh(self) -> Tensor:
        ...
    
    def arccosh_(self) -> Tensor:
        ...
    
    def arcsin(self) -> Tensor:
        ...
    
    def arcsin_(self) -> Tensor:
        ...
    
    def arcsinh(self) -> Tensor:
        ...
    
    def arcsinh_(self) -> Tensor:
        ...
    
    def arctan(self) -> Tensor:
        ...
    
    def arctan_(self) -> Tensor:
        ...
    
    def arctanh(self) -> Tensor:
        ...
    
    def arctanh_(self) -> Tensor:
        ...
    
    def argmax(self, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    def argmin(self, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def argsort(self, dim: _int = ..., descending: _bool = ...) -> Tensor:
        ...
    
    @overload
    def argsort(self, dim: Union[str, ellipsis, None], descending: _bool = ...) -> Tensor:
        ...
    
    def as_strided(self, size: _size, stride: _size, storage_offset: Optional[_int] = ...) -> Tensor:
        ...
    
    def as_strided_(self, size: _size, stride: _size, storage_offset: Optional[_int] = ...) -> Tensor:
        ...
    
    def as_subclass(self, cls: Tensor) -> Tensor:
        ...
    
    def asin(self) -> Tensor:
        ...
    
    def asin_(self) -> Tensor:
        ...
    
    def asinh(self) -> Tensor:
        ...
    
    def asinh_(self) -> Tensor:
        ...
    
    def atan(self) -> Tensor:
        ...
    
    def atan2(self, other: Tensor) -> Tensor:
        ...
    
    def atan2_(self, other: Tensor) -> Tensor:
        ...
    
    def atan_(self) -> Tensor:
        ...
    
    def atanh(self) -> Tensor:
        ...
    
    def atanh_(self) -> Tensor:
        ...
    
    def backward(self, gradient: Optional[Tensor] = ..., retain_graph: Optional[_bool] = ..., create_graph: _bool = ...) -> None:
        ...
    
    def baddbmm(self, batch1: Tensor, batch2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    def baddbmm_(self, batch1: Tensor, batch2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    @overload
    def bernoulli(self, *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def bernoulli(self, p: _float, *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def bernoulli_(self, p: Tensor, *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def bernoulli_(self, p: _float = ..., *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    def bfloat16(self) -> Tensor:
        ...
    
    def bincount(self, weights: Optional[Tensor] = ..., minlength: _int = ...) -> Tensor:
        ...
    
    @overload
    def bitwise_and(self, other: Number) -> Tensor:
        ...
    
    @overload
    def bitwise_and(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def bitwise_and_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def bitwise_and_(self, other: Tensor) -> Tensor:
        ...
    
    def bitwise_not(self) -> Tensor:
        ...
    
    def bitwise_not_(self) -> Tensor:
        ...
    
    @overload
    def bitwise_or(self, other: Number) -> Tensor:
        ...
    
    @overload
    def bitwise_or(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def bitwise_or_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def bitwise_or_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def bitwise_xor(self, other: Number) -> Tensor:
        ...
    
    @overload
    def bitwise_xor(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def bitwise_xor_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def bitwise_xor_(self, other: Tensor) -> Tensor:
        ...
    
    def bmm(self, mat2: Tensor) -> Tensor:
        ...
    
    def bool(self) -> Tensor:
        ...
    
    def byte(self) -> Tensor:
        ...
    
    def cauchy_(self, median: _float = ..., sigma: _float = ..., *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    def ceil(self) -> Tensor:
        ...
    
    def ceil_(self) -> Tensor:
        ...
    
    def char(self) -> Tensor:
        ...
    
    def cholesky(self, upper: _bool = ...) -> Tensor:
        ...
    
    def cholesky_inverse(self, upper: _bool = ...) -> Tensor:
        ...
    
    def cholesky_solve(self, input2: Tensor, upper: _bool = ...) -> Tensor:
        ...
    
    def chunk(self, chunks: _int, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
        ...
    
    def clamp(self, min: _float = ..., max: _float = ..., *, out: Optional[Tensor] = ...) -> Tensor:
        ...
    
    def clamp_(self, min: _float = ..., max: _float = ...) -> Tensor:
        ...
    
    def clamp_max(self, max: Number) -> Tensor:
        ...
    
    def clamp_max_(self, max: Number) -> Tensor:
        ...
    
    def clamp_min(self, min: Number) -> Tensor:
        ...
    
    def clamp_min_(self, min: Number) -> Tensor:
        ...
    
    def clip(self, min: Optional[Number] = ..., max: Optional[Number] = ...) -> Tensor:
        ...
    
    def clip_(self, min: Optional[Number] = ..., max: Optional[Number] = ...) -> Tensor:
        ...
    
    def clone(self, *, memory_format: Optional[memory_format] = ...) -> Tensor:
        ...
    
    def coalesce(self) -> Tensor:
        ...
    
    def conj(self) -> Tensor:
        ...
    
    def contiguous(self, memory_format=...) -> Tensor:
        ...
    
    def copy_(self, src: Tensor, non_blocking: _bool = ...) -> Tensor:
        ...
    
    def cos(self) -> Tensor:
        ...
    
    def cos_(self) -> Tensor:
        ...
    
    def cosh(self) -> Tensor:
        ...
    
    def cosh_(self) -> Tensor:
        ...
    
    @overload
    def count_nonzero(self, dim: _size) -> Tensor:
        ...
    
    @overload
    def count_nonzero(self, *dim: _int) -> Tensor:
        ...
    
    @overload
    def count_nonzero(self, dim: Optional[_int] = ...) -> Tensor:
        ...
    
    def cpu(self) -> Tensor:
        ...
    
    def cross(self, other: Tensor, dim: Optional[_int] = ...) -> Tensor:
        ...
    
    def cuda(self, device: Optional[Union[_device, _int, str]] = ..., non_blocking: _bool = ...) -> Tensor:
        ...
    
    @overload
    def cummax(self, dim: _int) -> namedtuple_values_indices:
        ...
    
    @overload
    def cummax(self, dim: Union[str, ellipsis, None]) -> namedtuple_values_indices:
        ...
    
    @overload
    def cummin(self, dim: _int) -> namedtuple_values_indices:
        ...
    
    @overload
    def cummin(self, dim: Union[str, ellipsis, None]) -> namedtuple_values_indices:
        ...
    
    @overload
    def cumprod(self, dim: _int, *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def cumprod(self, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def cumsum(self, dim: _int, *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def cumsum(self, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    def data_ptr(self) -> _int:
        ...
    
    def deg2rad(self) -> Tensor:
        ...
    
    def deg2rad_(self) -> Tensor:
        ...
    
    def dense_dim(self) -> _int:
        ...
    
    def dequantize(self) -> Tensor:
        ...
    
    def det(self) -> Tensor:
        ...
    
    def detach(self) -> Tensor:
        ...
    
    def detach_(self) -> Tensor:
        ...
    
    def diag(self, diagonal: _int = ...) -> Tensor:
        ...
    
    def diag_embed(self, offset: _int = ..., dim1: _int = ..., dim2: _int = ...) -> Tensor:
        ...
    
    def diagflat(self, offset: _int = ...) -> Tensor:
        ...
    
    @overload
    def diagonal(self, offset: _int = ..., dim1: _int = ..., dim2: _int = ...) -> Tensor:
        ...
    
    @overload
    def diagonal(self, *, outdim: Union[str, ellipsis, None], dim1: Union[str, ellipsis, None], dim2: Union[str, ellipsis, None], offset: _int = ...) -> Tensor:
        ...
    
    def digamma(self) -> Tensor:
        ...
    
    def digamma_(self) -> Tensor:
        ...
    
    def dim(self) -> _int:
        ...
    
    def dist(self, other: Tensor, p: Number = ...) -> Tensor:
        ...
    
    def div(self, other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
        ...
    
    def div_(self, other: Union[Tensor, Number]) -> Tensor:
        ...
    
    @overload
    def divide(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def divide(self, other: Number) -> Tensor:
        ...
    
    @overload
    def divide_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def divide_(self, other: Number) -> Tensor:
        ...
    
    def dot(self, tensor: Tensor) -> Tensor:
        ...
    
    def double(self) -> Tensor:
        ...
    
    def eig(self, eigenvectors: _bool = ...) -> namedtuple_eigenvalues_eigenvectors:
        ...
    
    def element_size(self) -> _int:
        ...
    
    @overload
    def eq(self, other: Number) -> Tensor:
        ...
    
    @overload
    def eq(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def eq_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def eq_(self, other: Tensor) -> Tensor:
        ...
    
    def equal(self, other: Tensor) -> _bool:
        ...
    
    def erf(self) -> Tensor:
        ...
    
    def erf_(self) -> Tensor:
        ...
    
    def erfc(self) -> Tensor:
        ...
    
    def erfc_(self) -> Tensor:
        ...
    
    def erfinv(self) -> Tensor:
        ...
    
    def erfinv_(self) -> Tensor:
        ...
    
    def exp(self) -> Tensor:
        ...
    
    def exp2(self) -> Tensor:
        ...
    
    def exp2_(self) -> Tensor:
        ...
    
    def exp_(self) -> Tensor:
        ...
    
    @overload
    def expand(self, size: _size, *, implicit: _bool = ...) -> Tensor:
        ...
    
    @overload
    def expand(self, *size: _int, implicit: _bool = ...) -> Tensor:
        ...
    
    def expand_as(self, other: Tensor) -> Tensor:
        ...
    
    def expm1(self) -> Tensor:
        ...
    
    def expm1_(self) -> Tensor:
        ...
    
    def exponential_(self, lambd: _float = ..., *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    def fft(self, signal_ndim: _int, normalized: _bool = ...) -> Tensor:
        ...
    
    @overload
    def fill_(self, value: Number) -> Tensor:
        ...
    
    @overload
    def fill_(self, value: Tensor) -> Tensor:
        ...
    
    def fill_diagonal_(self, fill_value: Number, wrap: _bool = ...) -> Tensor:
        ...
    
    def fix(self) -> Tensor:
        ...
    
    def fix_(self) -> Tensor:
        ...
    
    @overload
    def flatten(self, start_dim: _int = ..., end_dim: _int = ...) -> Tensor:
        ...
    
    @overload
    def flatten(self, start_dim: _int, end_dim: _int, out_dim: Union[str, ellipsis, None]) -> Tensor:
        ...
    
    @overload
    def flatten(self, start_dim: Union[str, ellipsis, None], end_dim: Union[str, ellipsis, None], out_dim: Union[str, ellipsis, None]) -> Tensor:
        ...
    
    @overload
    def flatten(self, dims: Sequence[Union[str, ellipsis, None]], out_dim: Union[str, ellipsis, None]) -> Tensor:
        ...
    
    @overload
    def flip(self, dims: _size) -> Tensor:
        ...
    
    @overload
    def flip(self, *dims: _int) -> Tensor:
        ...
    
    def fliplr(self) -> Tensor:
        ...
    
    def flipud(self) -> Tensor:
        ...
    
    def float(self) -> Tensor:
        ...
    
    def floor(self) -> Tensor:
        ...
    
    def floor_(self) -> Tensor:
        ...
    
    def floor_divide(self, other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
        ...
    
    def floor_divide_(self, other: Union[Tensor, Number]) -> Tensor:
        ...
    
    @overload
    def fmod(self, other: Number) -> Tensor:
        ...
    
    @overload
    def fmod(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def fmod_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def fmod_(self, other: Tensor) -> Tensor:
        ...
    
    def frac(self) -> Tensor:
        ...
    
    def frac_(self) -> Tensor:
        ...
    
    @overload
    def gather(self, dim: _int, index: Tensor, *, sparse_grad: _bool = ...) -> Tensor:
        ...
    
    @overload
    def gather(self, dim: Union[str, ellipsis, None], index: Tensor, *, sparse_grad: _bool = ...) -> Tensor:
        ...
    
    def gcd(self, other: Tensor) -> Tensor:
        ...
    
    def gcd_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def ge(self, other: Number) -> Tensor:
        ...
    
    @overload
    def ge(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def ge_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def ge_(self, other: Tensor) -> Tensor:
        ...
    
    def geometric_(self, p: _float, *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    def geqrf(self) -> namedtuple_a_tau:
        ...
    
    def ger(self, vec2: Tensor) -> Tensor:
        ...
    
    def get_device(self) -> _int:
        ...
    
    @overload
    def greater(self, other: Number) -> Tensor:
        ...
    
    @overload
    def greater(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def greater_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def greater_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def greater_equal(self, other: Number) -> Tensor:
        ...
    
    @overload
    def greater_equal(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def greater_equal_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def greater_equal_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def gt(self, other: Number) -> Tensor:
        ...
    
    @overload
    def gt(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def gt_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def gt_(self, other: Tensor) -> Tensor:
        ...
    
    def half(self) -> Tensor:
        ...
    
    def hardshrink(self, lambd: Number = ...) -> Tensor:
        ...
    
    def heaviside(self, values: Tensor) -> Tensor:
        ...
    
    def heaviside_(self, values: Tensor) -> Tensor:
        ...
    
    def histc(self, bins: _int = ..., min: Number = ..., max: Number = ...) -> Tensor:
        ...
    
    def hypot(self, other: Tensor) -> Tensor:
        ...
    
    def hypot_(self, other: Tensor) -> Tensor:
        ...
    
    def i0(self) -> Tensor:
        ...
    
    def i0_(self) -> Tensor:
        ...
    
    def ifft(self, signal_ndim: _int, normalized: _bool = ...) -> Tensor:
        ...
    
    @overload
    def index_add(self, dim: _int, index: Tensor, source: Tensor) -> Tensor:
        ...
    
    @overload
    def index_add(self, dim: Union[str, ellipsis, None], index: Tensor, source: Tensor) -> Tensor:
        ...
    
    def index_add_(self, dim: _int, index: Tensor, source: Tensor) -> Tensor:
        ...
    
    @overload
    def index_copy(self, dim: _int, index: Tensor, source: Tensor) -> Tensor:
        ...
    
    @overload
    def index_copy(self, dim: Union[str, ellipsis, None], index: Tensor, source: Tensor) -> Tensor:
        ...
    
    @overload
    def index_copy_(self, dim: _int, index: Tensor, source: Tensor) -> Tensor:
        ...
    
    @overload
    def index_copy_(self, dim: Union[str, ellipsis, None], index: Tensor, source: Tensor) -> Tensor:
        ...
    
    @overload
    def index_fill(self, dim: _int, index: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def index_fill(self, dim: _int, index: Tensor, value: Tensor) -> Tensor:
        ...
    
    @overload
    def index_fill(self, dim: Union[str, ellipsis, None], index: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def index_fill(self, dim: Union[str, ellipsis, None], index: Tensor, value: Tensor) -> Tensor:
        ...
    
    @overload
    def index_fill_(self, dim: _int, index: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def index_fill_(self, dim: _int, index: Tensor, value: Tensor) -> Tensor:
        ...
    
    @overload
    def index_fill_(self, dim: Union[str, ellipsis, None], index: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def index_fill_(self, dim: Union[str, ellipsis, None], index: Tensor, value: Tensor) -> Tensor:
        ...
    
    def index_put(self, indices: Optional[Union[Tuple[Tensor, ...], List[Tensor]]], values: Tensor, accumulate: _bool = ...) -> Tensor:
        ...
    
    def index_put_(self, indices: Optional[Union[Tuple[Tensor, ...], List[Tensor]]], values: Tensor, accumulate: _bool = ...) -> Tensor:
        ...
    
    @overload
    def index_select(self, dim: _int, index: Tensor) -> Tensor:
        ...
    
    @overload
    def index_select(self, dim: Union[str, ellipsis, None], index: Tensor) -> Tensor:
        ...
    
    def indices(self) -> Tensor:
        ...
    
    def int(self) -> Tensor:
        ...
    
    def int_repr(self) -> Tensor:
        ...
    
    def inverse(self) -> Tensor:
        ...
    
    def irfft(self, signal_ndim: _int, normalized: _bool = ..., onesided: _bool = ..., signal_sizes: _size = ...) -> Tensor:
        ...
    
    def is_coalesced(self) -> _bool:
        ...
    
    def is_complex(self) -> _bool:
        ...
    
    def is_contiguous(self, memory_format=...) -> _bool:
        ...
    
    is_cuda: _bool
    def is_distributed(self) -> _bool:
        ...
    
    def is_floating_point(self) -> _bool:
        ...
    
    is_leaf: _bool
    is_meta: _bool
    is_mkldnn: _bool
    def is_nonzero(self) -> _bool:
        ...
    
    def is_pinned(self) -> _bool:
        ...
    
    is_quantized: _bool
    def is_same_size(self, other: Tensor) -> _bool:
        ...
    
    def is_set_to(self, tensor: Tensor) -> _bool:
        ...
    
    def is_signed(self) -> _bool:
        ...
    
    is_sparse: _bool
    def isclose(self, other: Tensor, rtol: _float = ..., atol: _float = ..., equal_nan: _bool = ...) -> Tensor:
        ...
    
    def isfinite(self) -> Tensor:
        ...
    
    def isinf(self) -> Tensor:
        ...
    
    def isnan(self) -> Tensor:
        ...
    
    def isneginf(self) -> Tensor:
        ...
    
    def isposinf(self) -> Tensor:
        ...
    
    def isreal(self) -> Tensor:
        ...
    
    def item(self) -> Number:
        ...
    
    @overload
    def kthvalue(self, k: _int, dim: _int = ..., keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def kthvalue(self, k: _int, dim: Union[str, ellipsis, None], keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    def lcm(self, other: Tensor) -> Tensor:
        ...
    
    def lcm_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def le(self, other: Number) -> Tensor:
        ...
    
    @overload
    def le(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def le_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def le_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def lerp(self, end: Tensor, weight: Number) -> Tensor:
        ...
    
    @overload
    def lerp(self, end: Tensor, weight: Tensor) -> Tensor:
        ...
    
    @overload
    def lerp_(self, end: Tensor, weight: Number) -> Tensor:
        ...
    
    @overload
    def lerp_(self, end: Tensor, weight: Tensor) -> Tensor:
        ...
    
    @overload
    def less(self, other: Number) -> Tensor:
        ...
    
    @overload
    def less(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def less_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def less_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def less_equal(self, other: Number) -> Tensor:
        ...
    
    @overload
    def less_equal(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def less_equal_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def less_equal_(self, other: Tensor) -> Tensor:
        ...
    
    def lgamma(self) -> Tensor:
        ...
    
    def lgamma_(self) -> Tensor:
        ...
    
    def log(self) -> Tensor:
        ...
    
    def log10(self) -> Tensor:
        ...
    
    def log10_(self) -> Tensor:
        ...
    
    def log1p(self) -> Tensor:
        ...
    
    def log1p_(self) -> Tensor:
        ...
    
    def log2(self) -> Tensor:
        ...
    
    def log2_(self) -> Tensor:
        ...
    
    def log_(self) -> Tensor:
        ...
    
    def log_normal_(self, mean: _float = ..., std: _float = ..., *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def log_softmax(self, dim: _int, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def log_softmax(self, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    def logaddexp(self, other: Tensor) -> Tensor:
        ...
    
    def logaddexp2(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def logcumsumexp(self, dim: _int) -> Tensor:
        ...
    
    @overload
    def logcumsumexp(self, dim: Union[str, ellipsis, None]) -> Tensor:
        ...
    
    def logdet(self) -> Tensor:
        ...
    
    def logical_and(self, other: Tensor) -> Tensor:
        ...
    
    def logical_and_(self, other: Tensor) -> Tensor:
        ...
    
    def logical_not(self) -> Tensor:
        ...
    
    def logical_not_(self) -> Tensor:
        ...
    
    def logical_or(self, other: Tensor) -> Tensor:
        ...
    
    def logical_or_(self, other: Tensor) -> Tensor:
        ...
    
    def logical_xor(self, other: Tensor) -> Tensor:
        ...
    
    def logical_xor_(self, other: Tensor) -> Tensor:
        ...
    
    def logit(self, eps: Optional[_float] = ...) -> Tensor:
        ...
    
    def logit_(self, eps: Optional[_float] = ...) -> Tensor:
        ...
    
    @overload
    def logsumexp(self, dim: Union[_int, _size], keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def logsumexp(self, dim: Sequence[Union[str, ellipsis, None]], keepdim: _bool = ...) -> Tensor:
        ...
    
    def long(self) -> Tensor:
        ...
    
    def lstsq(self, A: Tensor) -> namedtuple_solution_QR:
        ...
    
    @overload
    def lt(self, other: Number) -> Tensor:
        ...
    
    @overload
    def lt(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def lt_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def lt_(self, other: Tensor) -> Tensor:
        ...
    
    def lu_solve(self, LU_data: Tensor, LU_pivots: Tensor) -> Tensor:
        ...
    
    def map_(self, tensor: Tensor, callable: Callable) -> Tensor:
        ...
    
    @overload
    def masked_fill(self, mask: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def masked_fill(self, mask: Tensor, value: Tensor) -> Tensor:
        ...
    
    @overload
    def masked_fill_(self, mask: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def masked_fill_(self, mask: Tensor, value: Tensor) -> Tensor:
        ...
    
    def masked_scatter(self, mask: Tensor, source: Tensor) -> Tensor:
        ...
    
    def masked_scatter_(self, mask: Tensor, source: Tensor) -> Tensor:
        ...
    
    def masked_select(self, mask: Tensor) -> Tensor:
        ...
    
    def matmul(self, other: Tensor) -> Tensor:
        ...
    
    def matrix_exp(self) -> Tensor:
        ...
    
    def matrix_power(self, n: _int) -> Tensor:
        ...
    
    @overload
    def max(self, dim: _int, keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def max(self, dim: Union[str, ellipsis, None], keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def max(self) -> Tensor:
        ...
    
    @overload
    def max(self, other: Tensor) -> Tensor:
        ...
    
    def maximum(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def mean(self, *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def mean(self, dim: Union[_int, _size], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def mean(self, dim: Sequence[Union[str, ellipsis, None]], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def median(self, dim: _int, keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def median(self, dim: Union[str, ellipsis, None], keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def median(self) -> Tensor:
        ...
    
    @overload
    def min(self, dim: _int, keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def min(self, dim: Union[str, ellipsis, None], keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def min(self) -> Tensor:
        ...
    
    @overload
    def min(self, other: Tensor) -> Tensor:
        ...
    
    def minimum(self, other: Tensor) -> Tensor:
        ...
    
    def mm(self, mat2: Tensor) -> Tensor:
        ...
    
    @overload
    def mode(self, dim: _int = ..., keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def mode(self, dim: Union[str, ellipsis, None], keepdim: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def movedim(self, source: _size, destination: _size) -> Tensor:
        ...
    
    @overload
    def movedim(self, source: _int, destination: _int) -> Tensor:
        ...
    
    def mul(self, other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
        ...
    
    def mul_(self, other: Union[Tensor, Number]) -> Tensor:
        ...
    
    def multinomial(self, num_samples: _int, replacement: _bool = ..., *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def multiply(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def multiply(self, other: Number) -> Tensor:
        ...
    
    @overload
    def multiply_(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def multiply_(self, other: Number) -> Tensor:
        ...
    
    def mv(self, vec: Tensor) -> Tensor:
        ...
    
    def mvlgamma(self, p: _int) -> Tensor:
        ...
    
    def mvlgamma_(self, p: _int) -> Tensor:
        ...
    
    @overload
    def nanquantile(self, q: _float, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def nanquantile(self, q: Tensor, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def nansum(self, *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def nansum(self, dim: Union[_int, _size], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def narrow(self, dim: _int, start: _int, length: _int) -> Tensor:
        ...
    
    @overload
    def narrow(self, dim: _int, start: Tensor, length: _int) -> Tensor:
        ...
    
    def narrow_copy(self, dim: _int, start: _int, length: _int) -> Tensor:
        ...
    
    def ndimension(self) -> _int:
        ...
    
    @overload
    def ne(self, other: Number) -> Tensor:
        ...
    
    @overload
    def ne(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def ne_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def ne_(self, other: Tensor) -> Tensor:
        ...
    
    def neg(self) -> Tensor:
        ...
    
    def neg_(self) -> Tensor:
        ...
    
    def negative(self) -> Tensor:
        ...
    
    def negative_(self) -> Tensor:
        ...
    
    def nelement(self) -> _int:
        ...
    
    @overload
    def new(self, *args: Any, device: Union[_device, str, None] = ...) -> Tensor:
        ...
    
    @overload
    def new(self, storage: Storage) -> Tensor:
        ...
    
    @overload
    def new(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def new(self, size: _size, *, device: Union[_device, str, None] = ...) -> Tensor:
        ...
    
    @overload
    def new_empty(self, size: _size, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
        ...
    
    @overload
    def new_empty(self, *size: _int, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
        ...
    
    def new_full(self, size: _size, fill_value: Number, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
        ...
    
    def new_ones(self, size: _size, dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
        ...
    
    def new_tensor(self, data: Any, dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
        ...
    
    @overload
    def new_zeros(self, size: _size, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
        ...
    
    @overload
    def new_zeros(self, *size: _int, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
        ...
    
    def nextafter(self, other: Tensor) -> Tensor:
        ...
    
    def nextafter_(self, other: Tensor) -> Tensor:
        ...
    
    def nonzero(self, *, as_tuple: _bool = ...) -> Tensor:
        ...
    
    def normal_(self, mean: _float = ..., std: _float = ..., *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def not_equal(self, other: Number) -> Tensor:
        ...
    
    @overload
    def not_equal(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def not_equal_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def not_equal_(self, other: Tensor) -> Tensor:
        ...
    
    def numel(self) -> _int:
        ...
    
    def numpy(self) -> Any:
        ...
    
    def orgqr(self, input2: Tensor) -> Tensor:
        ...
    
    def ormqr(self, input2: Tensor, input3: Tensor, left: _bool = ..., transpose: _bool = ...) -> Tensor:
        ...
    
    def outer(self, vec2: Tensor) -> Tensor:
        ...
    
    @overload
    def permute(self, dims: _size) -> Tensor:
        ...
    
    @overload
    def permute(self, *dims: _int) -> Tensor:
        ...
    
    def pin_memory(self) -> Tensor:
        ...
    
    def pinverse(self, rcond: _float = ...) -> Tensor:
        ...
    
    def polygamma(self, n: _int) -> Tensor:
        ...
    
    def polygamma_(self, n: _int) -> Tensor:
        ...
    
    @overload
    def pow(self, exponent: Tensor) -> Tensor:
        ...
    
    @overload
    def pow(self, exponent: Number) -> Tensor:
        ...
    
    @overload
    def pow_(self, exponent: Number) -> Tensor:
        ...
    
    @overload
    def pow_(self, exponent: Tensor) -> Tensor:
        ...
    
    def prelu(self, weight: Tensor) -> Tensor:
        ...
    
    @overload
    def prod(self, *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def prod(self, dim: _int, keepdim: _bool = ..., *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def prod(self, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    def put_(self, index: Tensor, source: Tensor, accumulate: _bool = ...) -> Tensor:
        ...
    
    def q_per_channel_axis(self) -> _int:
        ...
    
    def q_per_channel_scales(self) -> Tensor:
        ...
    
    def q_per_channel_zero_points(self) -> Tensor:
        ...
    
    def q_scale(self) -> _float:
        ...
    
    def q_zero_point(self) -> _int:
        ...
    
    def qr(self, some: _bool = ...) -> namedtuple_Q_R:
        ...
    
    def qscheme(self) -> _qscheme:
        ...
    
    @overload
    def quantile(self, q: _float, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def quantile(self, q: Tensor, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    def rad2deg(self) -> Tensor:
        ...
    
    def rad2deg_(self) -> Tensor:
        ...
    
    @overload
    def random_(self, from_: _int, to: Optional[_int], *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def random_(self, to: _int, *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    @overload
    def random_(self, *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    def reciprocal(self) -> Tensor:
        ...
    
    def reciprocal_(self) -> Tensor:
        ...
    
    def refine_names(self, names: Sequence[Union[str, ellipsis, None]]) -> Tensor:
        ...
    
    def relu(self) -> Tensor:
        ...
    
    def relu_(self) -> Tensor:
        ...
    
    @overload
    def remainder(self, other: Number) -> Tensor:
        ...
    
    @overload
    def remainder(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def remainder_(self, other: Number) -> Tensor:
        ...
    
    @overload
    def remainder_(self, other: Tensor) -> Tensor:
        ...
    
    def rename(self, names: Optional[Sequence[Union[str, ellipsis, None]]]) -> Tensor:
        ...
    
    def rename_(self, names: Optional[Sequence[Union[str, ellipsis, None]]]) -> Tensor:
        ...
    
    def renorm(self, p: Number, dim: _int, maxnorm: Number) -> Tensor:
        ...
    
    def renorm_(self, p: Number, dim: _int, maxnorm: Number) -> Tensor:
        ...
    
    @overload
    def repeat(self, repeats: _size) -> Tensor:
        ...
    
    @overload
    def repeat(self, *repeats: _int) -> Tensor:
        ...
    
    @overload
    def repeat_interleave(self, repeats: Tensor, dim: Optional[_int] = ...) -> Tensor:
        ...
    
    @overload
    def repeat_interleave(self, repeats: _int, dim: Optional[_int] = ...) -> Tensor:
        ...
    
    def requires_grad_(self, mode: _bool = ...) -> Tensor:
        ...
    
    @overload
    def reshape(self, shape: _size) -> Tensor:
        ...
    
    @overload
    def reshape(self, *shape: _int) -> Tensor:
        ...
    
    def reshape_as(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def resize_(self, size: _size, *, memory_format: Optional[memory_format] = ...) -> Tensor:
        ...
    
    @overload
    def resize_(self, *size: _int, memory_format: Optional[memory_format] = ...) -> Tensor:
        ...
    
    def resize_as_(self, the_template: Tensor, *, memory_format: Optional[memory_format] = ...) -> Tensor:
        ...
    
    def rfft(self, signal_ndim: _int, normalized: _bool = ..., onesided: _bool = ...) -> Tensor:
        ...
    
    def roll(self, shifts: Union[_int, _size], dims: Union[_int, _size] = ...) -> Tensor:
        ...
    
    def rot90(self, k: _int = ..., dims: _size = ...) -> Tensor:
        ...
    
    def round(self) -> Tensor:
        ...
    
    def round_(self) -> Tensor:
        ...
    
    def rsqrt(self) -> Tensor:
        ...
    
    def rsqrt_(self) -> Tensor:
        ...
    
    @overload
    def scatter(self, dim: _int, index: Tensor, src: Tensor) -> Tensor:
        ...
    
    @overload
    def scatter(self, dim: _int, index: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def scatter(self, dim: Union[str, ellipsis, None], index: Tensor, src: Tensor) -> Tensor:
        ...
    
    @overload
    def scatter(self, dim: Union[str, ellipsis, None], index: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def scatter_(self, dim: _int, index: Tensor, src: Tensor) -> Tensor:
        ...
    
    @overload
    def scatter_(self, dim: _int, index: Tensor, value: Number) -> Tensor:
        ...
    
    @overload
    def scatter_(self, dim: _int, index: Tensor, src: Tensor, *, reduce: str) -> Tensor:
        ...
    
    @overload
    def scatter_(self, dim: _int, index: Tensor, value: Number, *, reduce: str) -> Tensor:
        ...
    
    @overload
    def scatter_add(self, dim: _int, index: Tensor, src: Tensor) -> Tensor:
        ...
    
    @overload
    def scatter_add(self, dim: Union[str, ellipsis, None], index: Tensor, src: Tensor) -> Tensor:
        ...
    
    def scatter_add_(self, dim: _int, index: Tensor, src: Tensor) -> Tensor:
        ...
    
    @overload
    def select(self, dim: Union[str, ellipsis, None], index: _int) -> Tensor:
        ...
    
    @overload
    def select(self, dim: _int, index: _int) -> Tensor:
        ...
    
    @overload
    def set_(self, storage: Storage, offset: _int, size: _size, stride: _size) -> Tensor:
        ...
    
    @overload
    def set_(self, storage: Storage) -> Tensor:
        ...
    
    def sgn(self) -> Tensor:
        ...
    
    def sgn_(self) -> Tensor:
        ...
    
    def short(self) -> Tensor:
        ...
    
    def sigmoid(self) -> Tensor:
        ...
    
    def sigmoid_(self) -> Tensor:
        ...
    
    def sign(self) -> Tensor:
        ...
    
    def sign_(self) -> Tensor:
        ...
    
    def signbit(self) -> Tensor:
        ...
    
    def sin(self) -> Tensor:
        ...
    
    def sin_(self) -> Tensor:
        ...
    
    def sinh(self) -> Tensor:
        ...
    
    def sinh_(self) -> Tensor:
        ...
    
    @overload
    def size(self) -> Size:
        ...
    
    @overload
    def size(self, _int) -> _int:
        ...
    
    def slogdet(self) -> namedtuple_sign_logabsdet:
        ...
    
    def smm(self, mat2: Tensor) -> Tensor:
        ...
    
    @overload
    def softmax(self, dim: _int, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def softmax(self, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    def solve(self, A: Tensor) -> namedtuple_solution_LU:
        ...
    
    @overload
    def sort(self, dim: _int = ..., descending: _bool = ...) -> namedtuple_values_indices:
        ...
    
    @overload
    def sort(self, dim: Union[str, ellipsis, None], descending: _bool = ...) -> namedtuple_values_indices:
        ...
    
    def sparse_dim(self) -> _int:
        ...
    
    def sparse_mask(self, mask: Tensor) -> Tensor:
        ...
    
    def sparse_resize_(self, size: _size, sparse_dim: _int, dense_dim: _int) -> Tensor:
        ...
    
    def sparse_resize_and_clear_(self, size: _size, sparse_dim: _int, dense_dim: _int) -> Tensor:
        ...
    
    @overload
    def split(self, split_size: _int, dim: _int = ...) -> Sequence[Tensor]:
        ...
    
    @overload
    def split(self, split_size: Tuple[_int, ...], dim: _int = ...) -> Sequence[Tensor]:
        ...
    
    def split_with_sizes(self, split_sizes: _size, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
        ...
    
    def sqrt(self) -> Tensor:
        ...
    
    def sqrt_(self) -> Tensor:
        ...
    
    def square(self) -> Tensor:
        ...
    
    def square_(self) -> Tensor:
        ...
    
    @overload
    def squeeze(self) -> Tensor:
        ...
    
    @overload
    def squeeze(self, dim: _int) -> Tensor:
        ...
    
    @overload
    def squeeze(self, dim: Union[str, ellipsis, None]) -> Tensor:
        ...
    
    @overload
    def squeeze_(self) -> Tensor:
        ...
    
    @overload
    def squeeze_(self, dim: _int) -> Tensor:
        ...
    
    @overload
    def squeeze_(self, dim: Union[str, ellipsis, None]) -> Tensor:
        ...
    
    def sspaddmm(self, mat1: Tensor, mat2: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
        ...
    
    @overload
    def std(self, unbiased: _bool = ...) -> Tensor:
        ...
    
    @overload
    def std(self, dim: Union[_int, _size], unbiased: _bool = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def std(self, dim: Sequence[Union[str, ellipsis, None]], unbiased: _bool = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    def storage(self) -> Storage:
        ...
    
    def storage_offset(self) -> _int:
        ...
    
    @overload
    def stride(self) -> Tuple[_int]:
        ...
    
    @overload
    def stride(self, _int) -> _int:
        ...
    
    def sub(self, other: Union[Tensor, Number], *, alpha: Optional[Number] = ..., out: Optional[Tensor] = ...) -> Tensor:
        ...
    
    def sub_(self, other: Union[Tensor, Number], *, alpha: Optional[Number] = ...) -> Tensor:
        ...
    
    @overload
    def subtract(self, other: Tensor, *, alpha: Number = ...) -> Tensor:
        ...
    
    @overload
    def subtract(self, other: Number, alpha: Number = ...) -> Tensor:
        ...
    
    @overload
    def subtract_(self, other: Tensor, *, alpha: Number = ...) -> Tensor:
        ...
    
    @overload
    def subtract_(self, other: Number, alpha: Number = ...) -> Tensor:
        ...
    
    @overload
    def sum(self, *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def sum(self, dim: Union[_int, _size], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def sum(self, dim: Sequence[Union[str, ellipsis, None]], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ...) -> Tensor:
        ...
    
    @overload
    def sum_to_size(self, size: _size) -> Tensor:
        ...
    
    @overload
    def sum_to_size(self, *size: _int) -> Tensor:
        ...
    
    def svd(self, some: _bool = ..., compute_uv: _bool = ...) -> namedtuple_U_S_V:
        ...
    
    def symeig(self, eigenvectors: _bool = ..., upper: _bool = ...) -> namedtuple_eigenvalues_eigenvectors:
        ...
    
    def t(self) -> Tensor:
        ...
    
    def t_(self) -> Tensor:
        ...
    
    def take(self, index: Tensor) -> Tensor:
        ...
    
    def tan(self) -> Tensor:
        ...
    
    def tan_(self) -> Tensor:
        ...
    
    def tanh(self) -> Tensor:
        ...
    
    def tanh_(self) -> Tensor:
        ...
    
    @overload
    def to(self, dtype: _dtype, non_blocking: _bool = ..., copy: _bool = ...) -> Tensor:
        ...
    
    @overload
    def to(self, device: Optional[Union[_device, str]] = ..., dtype: Optional[_dtype] = ..., non_blocking: _bool = ..., copy: _bool = ...) -> Tensor:
        ...
    
    @overload
    def to(self, other: Tensor, non_blocking: _bool = ..., copy: _bool = ...) -> Tensor:
        ...
    
    def to_dense(self) -> Tensor:
        ...
    
    def to_mkldnn(self) -> Tensor:
        ...
    
    @overload
    def to_sparse(self, sparse_dim: _int) -> Tensor:
        ...
    
    @overload
    def to_sparse(self) -> Tensor:
        ...
    
    def tolist(self) -> List:
        ...
    
    def topk(self, k: _int, dim: _int = ..., largest: _bool = ..., sorted: _bool = ...) -> namedtuple_values_indices:
        ...
    
    def trace(self) -> Tensor:
        ...
    
    @overload
    def transpose(self, dim0: _int, dim1: _int) -> Tensor:
        ...
    
    @overload
    def transpose(self, dim0: Union[str, ellipsis, None], dim1: Union[str, ellipsis, None]) -> Tensor:
        ...
    
    def transpose_(self, dim0: _int, dim1: _int) -> Tensor:
        ...
    
    def triangular_solve(self, A: Tensor, upper: _bool = ..., transpose: _bool = ..., unitriangular: _bool = ...) -> namedtuple_solution_cloned_coefficient:
        ...
    
    def tril(self, diagonal: _int = ...) -> Tensor:
        ...
    
    def tril_(self, diagonal: _int = ...) -> Tensor:
        ...
    
    def triu(self, diagonal: _int = ...) -> Tensor:
        ...
    
    def triu_(self, diagonal: _int = ...) -> Tensor:
        ...
    
    def true_divide(self, other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
        ...
    
    def true_divide_(self, other: Union[Tensor, Number]) -> Tensor:
        ...
    
    def trunc(self) -> Tensor:
        ...
    
    def trunc_(self) -> Tensor:
        ...
    
    @overload
    def type(self, dtype: None = ..., non_blocking: _bool = ...) -> str:
        ...
    
    @overload
    def type(self, dtype: Union[str, _dtype], non_blocking: _bool = ...) -> Tensor:
        ...
    
    def type_as(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def unbind(self, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
        ...
    
    @overload
    def unbind(self, dim: Union[str, ellipsis, None]) -> Union[Tuple[Tensor, ...], List[Tensor]]:
        ...
    
    @overload
    def unflatten(self, dim: _int, sizes: _size, names: Optional[Sequence[Union[str, ellipsis, None]]] = ...) -> Tensor:
        ...
    
    @overload
    def unflatten(self, dim: Union[str, ellipsis, None], sizes: _size, names: Sequence[Union[str, ellipsis, None]]) -> Tensor:
        ...
    
    def unfold(self, dimension: _int, size: _int, step: _int) -> Tensor:
        ...
    
    def uniform_(self, from_: _float = ..., to: _float = ..., *, generator: Optional[Generator] = ...) -> Tensor:
        ...
    
    def unsafe_chunk(self, chunks: _int, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
        ...
    
    def unsafe_split(self, split_size: _int, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
        ...
    
    def unsafe_split_with_sizes(self, split_sizes: _size, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
        ...
    
    def unsqueeze(self, dim: _int) -> Tensor:
        ...
    
    def unsqueeze_(self, dim: _int) -> Tensor:
        ...
    
    def values(self) -> Tensor:
        ...
    
    @overload
    def var(self, unbiased: _bool = ...) -> Tensor:
        ...
    
    @overload
    def var(self, dim: Union[_int, _size], unbiased: _bool = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    @overload
    def var(self, dim: Sequence[Union[str, ellipsis, None]], unbiased: _bool = ..., keepdim: _bool = ...) -> Tensor:
        ...
    
    def vdot(self, other: Tensor) -> Tensor:
        ...
    
    @overload
    def view(self, size: _size) -> Tensor:
        ...
    
    @overload
    def view(self, *size: _int) -> Tensor:
        ...
    
    def view_as(self, other: Tensor) -> Tensor:
        ...
    
    def where(self, condition: Tensor, other: Tensor) -> Tensor:
        ...
    
    def zero_(self) -> Tensor:
        ...
    


class _CudaDeviceProperties:
    name: str
    major: _int
    minor: _int
    multi_processor_count: _int
    total_memory: _int
    is_integrated: _int
    is_multi_gpu_board: _int
    ...


class _CudaStreamBase:
    _cdata: _int
    device: _device
    cuda_stream: _int
    priority: _int
    def __new__(self, priority: _int = ..., _cdata: _int = ...) -> _CudaStreamBase:
        ...
    
    def query(self) -> _bool:
        ...
    
    def synchronize(self) -> None:
        ...
    
    def priority_range(self) -> Tuple[_int, _int]:
        ...
    


class _CudaEventBase:
    device: _device
    cuda_event: _int
    def __new__(cls, enable_timing: _bool = ..., blocking: _bool = ..., interprocess: _bool = ...) -> _CudaEventBase:
        ...
    
    @classmethod
    def from_ipc_handle(cls, device: _device, ipc_handle: bytes) -> _CudaEventBase:
        ...
    
    def record(self, stream: _CudaStreamBase) -> None:
        ...
    
    def wait(self, stream: _CudaStreamBase) -> None:
        ...
    
    def query(self) -> _bool:
        ...
    
    def elapsed_time(self, other: _CudaEventBase) -> _float:
        ...
    
    def synchronize(self) -> None:
        ...
    
    def ipc_handle(self) -> bytes:
        ...
    


class TracingState:
    ...


class IValue:
    ...


Stack = List[IValue]
class JitType:
    ...


R = TypeVar('R', bound=JitType)
class AnyType(JitType):
    @staticmethod
    def get() -> AnyType:
        ...
    


class NoneType(JitType):
    @staticmethod
    def get() -> NoneType:
        ...
    


class BoolType(JitType):
    @staticmethod
    def get() -> BoolType:
        ...
    


class FloatType(JitType):
    @staticmethod
    def get() -> FloatType:
        ...
    


class IntType(JitType):
    @staticmethod
    def get() -> IntType:
        ...
    


class StringType(JitType):
    @staticmethod
    def get() -> StringType:
        ...
    


class DeviceObjType(JitType):
    @staticmethod
    def get() -> DeviceObjType:
        ...
    


class ListType(JitType):
    def __init__(self, a: JitType) -> None:
        ...
    
    def getElementType(self) -> JitType:
        ...
    
    @staticmethod
    def ofInts() -> ListType:
        ...
    
    @staticmethod
    def ofTensors() -> ListType:
        ...
    
    @staticmethod
    def ofFloats() -> ListType:
        ...
    
    @staticmethod
    def ofBools() -> ListType:
        ...
    


class DictType(JitType):
    def __init__(self, key: JitType, value: JitType) -> None:
        ...
    
    def getKeyType(self) -> JitType:
        ...
    
    def getValueType(self) -> JitType:
        ...
    


class TupleType(JitType):
    def __init__(self, a: List[JitType]) -> None:
        ...
    


class ClassType(JitType):
    def __init__(self, qualified_name: str) -> None:
        ...
    


class InterfaceType(JitType):
    def __init__(self, qualified_name: str) -> None:
        ...
    
    def getMethod(self, name: str) -> Optional[FunctionSchema]:
        ...
    
    def getMethodNames(self) -> List[str]:
        ...
    


class OptionalType(JitType, Generic[R]):
    def __init__(self, a: JitType) -> None:
        ...
    
    def getElementType(self) -> JitType:
        ...
    
    @staticmethod
    def ofTensor() -> OptionalType:
        ...
    


class FutureType(JitType):
    def __init__(self, a: JitType) -> None:
        ...
    
    def getElementType(self) -> JitType:
        ...
    


class RRefType(JitType):
    def __init__(self, a: JitType) -> None:
        ...
    


class EnumType(JitType):
    def __init__(self, qualified_name: str, value_type: JitType, enum_names_values: List[Any]) -> None:
        ...
    


class TensorType(JitType):
    @classmethod
    def get(cls) -> TensorType:
        ...
    


class SourceRange:
    ...


class TreeView:
    ...


class Ident(TreeView):
    @property
    def name(self) -> str:
        ...
    


class ClassDef(TreeView):
    ...


class Def(TreeView):
    def name(self) -> Ident:
        ...
    


class Decl(TreeView):
    ...


