"""
This type stub file was generated by pyright.
"""

from torch import Generator, Tensor, memory_format
from typing import Any, List, NamedTuple, Optional, Sequence, Tuple, Union, overload
from torch.types import Number, _bool, _device, _dtype, _float, _int, _layout, _size

"""
This type stub file was generated by pyright.
"""
namedtuple_values_indices = NamedTuple("namedtuple_values_indices", [("values", Tensor), ("indices", Tensor)])
namedtuple_eigenvalues_eigenvectors = NamedTuple("namedtuple_eigenvalues_eigenvectors", [("eigenvalues", Tensor), ("eigenvectors", Tensor)])
namedtuple_a_tau = NamedTuple("namedtuple_a_tau", [("a", Tensor), ("tau", Tensor)])
namedtuple_solution_QR = NamedTuple("namedtuple_solution_QR", [("solution", Tensor), ("QR", Tensor)])
namedtuple_Q_R = NamedTuple("namedtuple_Q_R", [("Q", Tensor), ("R", Tensor)])
namedtuple_sign_logabsdet = NamedTuple("namedtuple_sign_logabsdet", [("sign", Tensor), ("logabsdet", Tensor)])
namedtuple_solution_LU = NamedTuple("namedtuple_solution_LU", [("solution", Tensor), ("LU", Tensor)])
namedtuple_U_S_V = NamedTuple("namedtuple_U_S_V", [("U", Tensor), ("S", Tensor), ("V", Tensor)])
namedtuple_solution_cloned_coefficient = NamedTuple("namedtuple_solution_cloned_coefficient", [("solution", Tensor), ("cloned_coefficient", Tensor)])
@overload
def __and__(input: Tensor, other: Number) -> Tensor:
    ...

@overload
def __and__(input: Tensor, other: Tensor) -> Tensor:
    ...

@overload
def __lshift__(input: Tensor, other: Number) -> Tensor:
    ...

@overload
def __lshift__(input: Tensor, other: Tensor) -> Tensor:
    ...

@overload
def __or__(input: Tensor, other: Number) -> Tensor:
    ...

@overload
def __or__(input: Tensor, other: Tensor) -> Tensor:
    ...

@overload
def __rshift__(input: Tensor, other: Number) -> Tensor:
    ...

@overload
def __rshift__(input: Tensor, other: Tensor) -> Tensor:
    ...

@overload
def __xor__(input: Tensor, other: Number) -> Tensor:
    ...

@overload
def __xor__(input: Tensor, other: Tensor) -> Tensor:
    ...

def abs(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def abs_(input: Tensor) -> Tensor:
    ...

def absolute(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def acos(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def acos_(input: Tensor) -> Tensor:
    ...

def acosh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def acosh_(input: Tensor) -> Tensor:
    ...

def adaptive_avg_pool1d(input: Tensor, output_size: Union[_int, _size]) -> Tensor:
    ...

def adaptive_max_pool1d(input: Tensor, output_size: Union[_int, _size]) -> Tuple[Tensor, Tensor]:
    ...

@overload
def add(input: Union[Tensor, Number], other: Union[Tensor, Number], *, alpha: Optional[Number] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def add(self: Tensor, alpha: Number, other: Tensor) -> Tensor:
    ...

@overload
def add(self: Tensor, alpha: Number, other: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addbmm(input: Tensor, batch1: Tensor, batch2: Tensor, *, beta: Number = ..., alpha: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def addbmm(beta: Number, self: Tensor, alpha: Number, batch1: Tensor, batch2: Tensor) -> Tensor:
    ...

@overload
def addbmm(beta: Number, self: Tensor, alpha: Number, batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addbmm(beta: Number, self: Tensor, batch1: Tensor, batch2: Tensor) -> Tensor:
    ...

@overload
def addbmm(beta: Number, self: Tensor, batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addcdiv(input: Tensor, tensor1: Tensor, tensor2: Tensor, *, value: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def addcdiv(self: Tensor, value: Number, tensor1: Tensor, tensor2: Tensor) -> Tensor:
    ...

@overload
def addcdiv(self: Tensor, value: Number, tensor1: Tensor, tensor2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addcmul(input: Tensor, tensor1: Tensor, tensor2: Tensor, *, value: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def addcmul(self: Tensor, value: Number, tensor1: Tensor, tensor2: Tensor) -> Tensor:
    ...

@overload
def addcmul(self: Tensor, value: Number, tensor1: Tensor, tensor2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addmm(input: Tensor, mat1: Tensor, mat2: Tensor, *, beta: Number = ..., alpha: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def addmm(beta: Number, self: Tensor, alpha: Number, mat1: Tensor, mat2: Tensor) -> Tensor:
    ...

@overload
def addmm(beta: Number, self: Tensor, alpha: Number, mat1: Tensor, mat2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addmm(beta: Number, self: Tensor, mat1: Tensor, mat2: Tensor) -> Tensor:
    ...

@overload
def addmm(beta: Number, self: Tensor, mat1: Tensor, mat2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addmv(input: Tensor, mat: Tensor, vec: Tensor, *, beta: Number = ..., alpha: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def addmv(beta: Number, self: Tensor, alpha: Number, mat: Tensor, vec: Tensor) -> Tensor:
    ...

@overload
def addmv(beta: Number, self: Tensor, alpha: Number, mat: Tensor, vec: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addmv(beta: Number, self: Tensor, mat: Tensor, vec: Tensor) -> Tensor:
    ...

@overload
def addmv(beta: Number, self: Tensor, mat: Tensor, vec: Tensor, *, out: Tensor) -> Tensor:
    ...

def addmv_(input: Tensor, mat: Tensor, vec: Tensor, *, beta: Number = ..., alpha: Number = ...) -> Tensor:
    ...

@overload
def addr(input: Tensor, vec1: Tensor, vec2: Tensor, *, beta: Number = ..., alpha: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def addr(beta: Number, self: Tensor, alpha: Number, vec1: Tensor, vec2: Tensor) -> Tensor:
    ...

@overload
def addr(beta: Number, self: Tensor, alpha: Number, vec1: Tensor, vec2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def addr(beta: Number, self: Tensor, vec1: Tensor, vec2: Tensor) -> Tensor:
    ...

@overload
def addr(beta: Number, self: Tensor, vec1: Tensor, vec2: Tensor, *, out: Tensor) -> Tensor:
    ...

def affine_grid_generator(theta: Tensor, size: _size, align_corners: _bool) -> Tensor:
    ...

@overload
def all(input: Tensor, dim: _int, keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def all(input: Tensor, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def all(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def allclose(input: Tensor, other: Tensor, rtol: _float = ..., atol: _float = ..., equal_nan: _bool = ...) -> _bool:
    ...

def alpha_dropout(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def alpha_dropout_(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def amax(input: Tensor, dim: Union[_int, _size] = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def amin(input: Tensor, dim: Union[_int, _size] = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def angle(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def any(input: Tensor, dim: _int, keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def any(input: Tensor, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def any(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def arange(start: Number, end: Number, step: Number, *, out: Optional[Tensor] = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def arange(start: Number, end: Number, *, out: Optional[Tensor] = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def arange(end: Number, *, out: Optional[Tensor] = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def arccos(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def arccos_(input: Tensor) -> Tensor:
    ...

def arccosh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def arccosh_(input: Tensor) -> Tensor:
    ...

def arcsin(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def arcsin_(input: Tensor) -> Tensor:
    ...

def arcsinh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def arcsinh_(input: Tensor) -> Tensor:
    ...

def arctan(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def arctan_(input: Tensor) -> Tensor:
    ...

def arctanh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def arctanh_(input: Tensor) -> Tensor:
    ...

def argmax(input: Tensor, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
    ...

def argmin(input: Tensor, dim: Optional[_int] = ..., keepdim: _bool = ...) -> Tensor:
    ...

@overload
def argsort(input: Tensor, dim: _int = ..., descending: _bool = ...) -> Tensor:
    ...

@overload
def argsort(input: Tensor, dim: Union[str, ellipsis, None], descending: _bool = ...) -> Tensor:
    ...

def as_strided(input: Tensor, size: _size, stride: _size, storage_offset: Optional[_int] = ...) -> Tensor:
    ...

def as_strided_(input: Tensor, size: _size, stride: _size, storage_offset: Optional[_int] = ...) -> Tensor:
    ...

def as_tensor(data: Any, dtype: _dtype = ..., device: Optional[_device] = ...) -> Tensor:
    ...

def asin(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def asin_(input: Tensor) -> Tensor:
    ...

def asinh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def asinh_(input: Tensor) -> Tensor:
    ...

def atan(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def atan2(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def atan_(input: Tensor) -> Tensor:
    ...

def atanh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def atanh_(input: Tensor) -> Tensor:
    ...

def avg_pool1d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., ceil_mode: _bool = ..., count_include_pad: _bool = ...) -> Tensor:
    ...

@overload
def baddbmm(input: Tensor, batch1: Tensor, batch2: Tensor, *, beta: Number = ..., alpha: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def baddbmm(beta: Number, self: Tensor, alpha: Number, batch1: Tensor, batch2: Tensor) -> Tensor:
    ...

@overload
def baddbmm(beta: Number, self: Tensor, alpha: Number, batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def baddbmm(beta: Number, self: Tensor, batch1: Tensor, batch2: Tensor) -> Tensor:
    ...

@overload
def baddbmm(beta: Number, self: Tensor, batch1: Tensor, batch2: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def bartlett_window(window_length: _int, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def bartlett_window(window_length: _int, periodic: _bool, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def batch_norm(input: Tensor, weight: Optional[Tensor], bias: Optional[Tensor], running_mean: Optional[Tensor], running_var: Optional[Tensor], training: _bool, momentum: _float, eps: _float, cudnn_enabled: _bool) -> Tensor:
    ...

def batch_norm_backward_elemt(grad_out: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, weight: Optional[Tensor], mean_dy: Tensor, mean_dy_xmu: Tensor) -> Tensor:
    ...

def batch_norm_backward_reduce(grad_out: Tensor, input: Tensor, mean: Tensor, invstd: Tensor, weight: Optional[Tensor], input_g: _bool, weight_g: _bool, bias_g: _bool) -> Tuple[Tensor, Tensor, Tensor, Tensor]:
    ...

def batch_norm_elemt(input: Tensor, weight: Optional[Tensor], bias: Optional[Tensor], mean: Tensor, invstd: Tensor, eps: _float, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def batch_norm_gather_stats(input: Tensor, mean: Tensor, invstd: Tensor, running_mean: Optional[Tensor], running_var: Optional[Tensor], momentum: _float, eps: _float, count: _int) -> Tuple[Tensor, Tensor]:
    ...

def batch_norm_gather_stats_with_counts(input: Tensor, mean: Tensor, invstd: Tensor, running_mean: Optional[Tensor], running_var: Optional[Tensor], momentum: _float, eps: _float, counts: Tensor) -> Tuple[Tensor, Tensor]:
    ...

def batch_norm_stats(input: Tensor, eps: _float) -> Tuple[Tensor, Tensor]:
    ...

def batch_norm_update_stats(input: Tensor, running_mean: Optional[Tensor], running_var: Optional[Tensor], momentum: _float) -> Tuple[Tensor, Tensor]:
    ...

@overload
def bernoulli(input: Tensor, *, generator: Optional[Generator] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bernoulli(input: Tensor, p: _float, *, generator: Optional[Generator] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

def bilinear(input1: Tensor, input2: Tensor, weight: Tensor, bias: Optional[Tensor]) -> Tensor:
    ...

def bincount(input: Tensor, weights: Optional[Tensor] = ..., minlength: _int = ...) -> Tensor:
    ...

def binomial(count: Tensor, prob: Tensor, generator: Optional[Generator] = ...) -> Tensor:
    ...

@overload
def bitwise_and(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bitwise_and(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def bitwise_not(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bitwise_or(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bitwise_or(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bitwise_xor(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bitwise_xor(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def blackman_window(window_length: _int, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def blackman_window(window_length: _int, periodic: _bool, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def bmm(input: Tensor, mat2: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bucketize(input: Tensor, boundaries: Tensor, *, out_int32: _bool = ..., right: _bool = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def bucketize(self: Number, boundaries: Tensor, *, out_int32: _bool = ..., right: _bool = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

def can_cast(from_: _dtype, to: _dtype) -> _bool:
    ...

@overload
def cat(tensors: Union[Tuple[Tensor, ...], List[Tensor]], dim: _int = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def cat(tensors: Union[Tuple[Tensor, ...], List[Tensor]], dim: Union[str, ellipsis, None], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def ceil(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def ceil_(input: Tensor) -> Tensor:
    ...

def celu(input: Tensor, alpha: Number = ...) -> Tensor:
    ...

def celu_(input: Tensor, alpha: Number = ...) -> Tensor:
    ...

def channel_shuffle(input: Tensor, groups: _int) -> Tensor:
    ...

def cholesky(input: Tensor, upper: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def cholesky_inverse(input: Tensor, upper: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def cholesky_solve(input: Tensor, input2: Tensor, upper: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def choose_qparams_optimized(input: Tensor, numel: _int, n_bins: _int, ratio: _float, bit_width: _int) -> Tuple[_float, _float]:
    ...

def chunk(input: Tensor, chunks: _int, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def clamp(self, min: _float = ..., max: _float = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def clamp_max(input: Tensor, max: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def clamp_max_(input: Tensor, max: Number) -> Tensor:
    ...

def clamp_min(input: Tensor, min: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def clamp_min_(input: Tensor, min: Number) -> Tensor:
    ...

def clip(input: Tensor, min: Optional[Number] = ..., max: Optional[Number] = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def clip_(input: Tensor, min: Optional[Number] = ..., max: Optional[Number] = ...) -> Tensor:
    ...

def clone(input: Tensor, *, memory_format: Optional[memory_format] = ...) -> Tensor:
    ...

def combinations(input: Tensor, r: _int = ..., with_replacement: _bool = ...) -> Tensor:
    ...

def complex(real: Tensor, imag: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def conj(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def constant_pad_nd(input: Tensor, pad: _size, value: Number = ...) -> Tensor:
    ...

def conv1d(input: Tensor, weight: Tensor, bias: Optional[Tensor] = ..., stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., groups: _int = ...) -> Tensor:
    ...

def conv2d(input: Tensor, weight: Tensor, bias: Optional[Tensor] = ..., stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., groups: _int = ...) -> Tensor:
    ...

def conv3d(input: Tensor, weight: Tensor, bias: Optional[Tensor] = ..., stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., groups: _int = ...) -> Tensor:
    ...

def conv_tbc(input: Tensor, weight: Tensor, bias: Tensor, pad: _int = ...) -> Tensor:
    ...

def conv_transpose1d(input: Tensor, weight: Tensor, bias: Optional[Tensor] = ..., stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., output_padding: Union[_int, _size] = ..., groups: _int = ..., dilation: Union[_int, _size] = ...) -> Tensor:
    ...

def conv_transpose2d(input: Tensor, weight: Tensor, bias: Optional[Tensor] = ..., stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., output_padding: Union[_int, _size] = ..., groups: _int = ..., dilation: Union[_int, _size] = ...) -> Tensor:
    ...

def conv_transpose3d(input: Tensor, weight: Tensor, bias: Optional[Tensor] = ..., stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., output_padding: Union[_int, _size] = ..., groups: _int = ..., dilation: Union[_int, _size] = ...) -> Tensor:
    ...

def convolution(input: Tensor, weight: Tensor, bias: Optional[Tensor], stride: _size, padding: _size, dilation: _size, transposed: _bool, output_padding: _size, groups: _int) -> Tensor:
    ...

def cos(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def cos_(input: Tensor) -> Tensor:
    ...

def cosh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def cosh_(input: Tensor) -> Tensor:
    ...

def cosine_similarity(x1: Tensor, x2: Tensor, dim: _int = ..., eps: _float = ...) -> Tensor:
    ...

@overload
def count_nonzero(input: Tensor, dim: _size) -> Tensor:
    ...

@overload
def count_nonzero(input: Tensor, dim: Optional[_int] = ...) -> Tensor:
    ...

def cross(input: Tensor, other: Tensor, dim: Optional[_int] = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def cudnn_affine_grid_generator(theta: Tensor, N: _int, C: _int, H: _int, W: _int) -> Tensor:
    ...

def cudnn_batch_norm(input: Tensor, weight: Tensor, bias: Optional[Tensor], running_mean: Optional[Tensor], running_var: Optional[Tensor], training: _bool, exponential_average_factor: _float, epsilon: _float) -> Tuple[Tensor, Tensor, Tensor, Tensor]:
    ...

@overload
def cudnn_convolution(input: Tensor, weight: Tensor, bias: Optional[Tensor], padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool) -> Tensor:
    ...

@overload
def cudnn_convolution(input: Tensor, weight: Tensor, padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool) -> Tensor:
    ...

@overload
def cudnn_convolution(input: Tensor, weight: Tensor, padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool, allow_tf32: _bool) -> Tensor:
    ...

@overload
def cudnn_convolution_transpose(input: Tensor, weight: Tensor, bias: Optional[Tensor], padding: _size, output_padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool) -> Tensor:
    ...

@overload
def cudnn_convolution_transpose(input: Tensor, weight: Tensor, padding: _size, output_padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool) -> Tensor:
    ...

@overload
def cudnn_convolution_transpose(input: Tensor, weight: Tensor, padding: _size, output_padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool, allow_tf32: _bool) -> Tensor:
    ...

def cudnn_grid_sampler(input: Tensor, grid: Tensor) -> Tensor:
    ...

def cudnn_is_acceptable(input: Tensor) -> _bool:
    ...

@overload
def cummax(input: Tensor, dim: _int, *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def cummax(input: Tensor, dim: Union[str, ellipsis, None], *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def cummin(input: Tensor, dim: _int, *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def cummin(input: Tensor, dim: Union[str, ellipsis, None], *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def cumprod(input: Tensor, dim: _int, *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def cumprod(input: Tensor, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def cumsum(input: Tensor, dim: _int, *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def cumsum(input: Tensor, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

def deg2rad(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def deg2rad_(input: Tensor) -> Tensor:
    ...

@overload
def dequantize(input: Tensor) -> Tensor:
    ...

@overload
def dequantize(tensors: Union[Tuple[Tensor, ...], List[Tensor]]) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def det(input: Tensor) -> Tensor:
    ...

def detach(input: Tensor) -> Tensor:
    ...

def detach_(input: Tensor) -> Tensor:
    ...

def diag(input: Tensor, diagonal: _int = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def diag_embed(input: Tensor, offset: _int = ..., dim1: _int = ..., dim2: _int = ...) -> Tensor:
    ...

def diagflat(input: Tensor, offset: _int = ...) -> Tensor:
    ...

@overload
def diagonal(input: Tensor, offset: _int = ..., dim1: _int = ..., dim2: _int = ...) -> Tensor:
    ...

@overload
def diagonal(input: Tensor, *, outdim: Union[str, ellipsis, None], dim1: Union[str, ellipsis, None], dim2: Union[str, ellipsis, None], offset: _int = ...) -> Tensor:
    ...

def digamma(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def dist(input: Tensor, other: Tensor, p: Number = ...) -> Tensor:
    ...

def div(input: Union[Tensor, Number], other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def divide(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def divide(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def dot(input: Tensor, tensor: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def dropout(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def dropout_(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def dstack(tensors: Union[Tuple[Tensor, ...], List[Tensor]], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def eig(input: Tensor, eigenvectors: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_eigenvalues_eigenvectors:
    ...

def embedding(weight: Tensor, indices: Tensor, padding_idx: _int = ..., scale_grad_by_freq: _bool = ..., sparse: _bool = ...) -> Tensor:
    ...

def embedding_bag(weight: Tensor, indices: Tensor, offsets: Tensor, scale_grad_by_freq: _bool = ..., mode: _int = ..., sparse: _bool = ..., per_sample_weights: Optional[Tensor] = ..., include_last_offset: _bool = ...) -> Tuple[Tensor, Tensor, Tensor, Tensor]:
    ...

def embedding_renorm_(input: Tensor, indices: Tensor, max_norm: _float, norm_type: _float) -> Tensor:
    ...

@overload
def empty(size: _size, *, names: Optional[Sequence[Union[str, ellipsis, None]]], memory_format: Optional[memory_format] = ..., out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def empty(*size: _int, names: Optional[Sequence[Union[str, ellipsis, None]]], memory_format: Optional[memory_format] = ..., out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def empty(size: _size, *, memory_format: Optional[memory_format] = ..., out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def empty(*size: _int, memory_format: Optional[memory_format] = ..., out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def empty_like(input: Tensor, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def empty_meta(size: _size, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def empty_meta(*size: _int, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def empty_quantized(size: _size, qtensor: Tensor) -> Tensor:
    ...

def empty_strided(size: _size, stride: _size, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def eq(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def eq(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def equal(input: Tensor, other: Tensor) -> _bool:
    ...

def erf(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def erf_(input: Tensor) -> Tensor:
    ...

def erfc(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def erfc_(input: Tensor) -> Tensor:
    ...

def erfinv(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def exp(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def exp2(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def exp2_(input: Tensor) -> Tensor:
    ...

def exp_(input: Tensor) -> Tensor:
    ...

def expm1(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def expm1_(input: Tensor) -> Tensor:
    ...

@overload
def eye(n: _int, *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def eye(n: _int, m: _int, *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def fake_quantize_per_channel_affine(input: Tensor, scale: Tensor, zero_point: Tensor, axis: _int, quant_min: _int, quant_max: _int) -> Tensor:
    ...

def fake_quantize_per_tensor_affine(input: Tensor, scale: _float, zero_point: _int, quant_min: _int, quant_max: _int) -> Tensor:
    ...

def fbgemm_linear_fp16_weight(input: Tensor, packed_weight: Tensor, bias: Tensor) -> Tensor:
    ...

def fbgemm_linear_fp16_weight_fp32_activation(input: Tensor, packed_weight: Tensor, bias: Tensor) -> Tensor:
    ...

def fbgemm_linear_int8_weight(input: Tensor, weight: Tensor, packed: Tensor, col_offsets: Tensor, weight_scale: Number, weight_zero_point: Number, bias: Tensor) -> Tensor:
    ...

def fbgemm_linear_int8_weight_fp32_activation(input: Tensor, weight: Tensor, packed: Tensor, col_offsets: Tensor, weight_scale: Number, weight_zero_point: Number, bias: Tensor) -> Tensor:
    ...

def fbgemm_linear_quantize_weight(input: Tensor) -> Tuple[Tensor, Tensor, _float, _int]:
    ...

def fbgemm_pack_gemm_matrix_fp16(input: Tensor) -> Tensor:
    ...

@overload
def fbgemm_pack_quantized_matrix(input: Tensor) -> Tensor:
    ...

@overload
def fbgemm_pack_quantized_matrix(input: Tensor, K: _int, N: _int) -> Tensor:
    ...

def feature_alpha_dropout(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def feature_alpha_dropout_(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def feature_dropout(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def feature_dropout_(input: Tensor, p: _float, train: _bool) -> Tensor:
    ...

def fft(input: Tensor, signal_ndim: _int, normalized: _bool = ...) -> Tensor:
    ...

@overload
def fill_(input: Tensor, value: Number) -> Tensor:
    ...

@overload
def fill_(input: Tensor, value: Tensor) -> Tensor:
    ...

def fix(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def fix_(input: Tensor) -> Tensor:
    ...

@overload
def flatten(input: Tensor, start_dim: _int = ..., end_dim: _int = ...) -> Tensor:
    ...

@overload
def flatten(input: Tensor, start_dim: _int, end_dim: _int, out_dim: Union[str, ellipsis, None]) -> Tensor:
    ...

@overload
def flatten(input: Tensor, start_dim: Union[str, ellipsis, None], end_dim: Union[str, ellipsis, None], out_dim: Union[str, ellipsis, None]) -> Tensor:
    ...

@overload
def flatten(input: Tensor, dims: Sequence[Union[str, ellipsis, None]], out_dim: Union[str, ellipsis, None]) -> Tensor:
    ...

def flip(input: Tensor, dims: _size) -> Tensor:
    ...

def fliplr(input: Tensor) -> Tensor:
    ...

def flipud(input: Tensor) -> Tensor:
    ...

def floor(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def floor_(input: Tensor) -> Tensor:
    ...

def floor_divide(input: Union[Tensor, Number], other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def fmod(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def fmod(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def frac(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def frac_(input: Tensor) -> Tensor:
    ...

@overload
def frobenius_norm(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def frobenius_norm(input: Tensor, dim: Union[_int, _size], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def from_file(filename: str, shared: Optional[_bool] = ..., size: Optional[_int] = ..., *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def from_numpy(ndarray) -> Tensor:
    ...

@overload
def full(size: _size, fill_value: Number, *, out: Optional[Tensor] = ..., layout: _layout = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def full(size: _size, fill_value: Number, *, names: List[Union[str, None]], layout: _layout = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def full_like(input: Tensor, fill_value: Number, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def gather(input: Tensor, dim: _int, index: Tensor, *, sparse_grad: _bool = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def gather(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, *, sparse_grad: _bool = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

def gcd(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def gcd_(input: Tensor, other: Tensor) -> Tensor:
    ...

@overload
def ge(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def ge(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def geqrf(input: Tensor, *, out: Optional[Tensor] = ...) -> namedtuple_a_tau:
    ...

def ger(input: Tensor, vec2: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def get_default_dtype() -> _dtype:
    ...

def get_num_interop_threads() -> _int:
    ...

def get_num_threads() -> _int:
    ...

@overload
def greater(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def greater(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def greater_equal(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def greater_equal(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def grid_sampler(input: Tensor, grid: Tensor, interpolation_mode: _int, padding_mode: _int, align_corners: _bool) -> Tensor:
    ...

def grid_sampler_2d(input: Tensor, grid: Tensor, interpolation_mode: _int, padding_mode: _int, align_corners: _bool) -> Tensor:
    ...

def grid_sampler_3d(input: Tensor, grid: Tensor, interpolation_mode: _int, padding_mode: _int, align_corners: _bool) -> Tensor:
    ...

def group_norm(input: Tensor, num_groups: _int, weight: Optional[Tensor] = ..., bias: Optional[Tensor] = ..., eps: _float = ..., cudnn_enabled: _bool = ...) -> Tensor:
    ...

@overload
def gru(input: Tensor, hx: Tensor, params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool, batch_first: _bool) -> Tuple[Tensor, Tensor]:
    ...

@overload
def gru(data: Tensor, batch_sizes: Tensor, hx: Tensor, params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool) -> Tuple[Tensor, Tensor]:
    ...

def gru_cell(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Optional[Tensor] = ..., b_hh: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def gt(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def gt(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def hamming_window(window_length: _int, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def hamming_window(window_length: _int, periodic: _bool, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def hamming_window(window_length: _int, periodic: _bool, alpha: _float, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def hamming_window(window_length: _int, periodic: _bool, alpha: _float, beta: _float, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def hann_window(window_length: _int, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def hann_window(window_length: _int, periodic: _bool, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def hardshrink(input: Tensor, lambd: Number = ...) -> Tensor:
    ...

def heaviside(input: Tensor, values: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def histc(input: Tensor, bins: _int = ..., min: Number = ..., max: Number = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def hspmm(mat1: Tensor, mat2: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def hstack(tensors: Union[Tuple[Tensor, ...], List[Tensor]], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def hypot(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def i0(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def i0_(input: Tensor) -> Tensor:
    ...

def ifft(input: Tensor, signal_ndim: _int, normalized: _bool = ...) -> Tensor:
    ...

def imag(input: Tensor) -> Tensor:
    ...

@overload
def index_add(input: Tensor, dim: _int, index: Tensor, source: Tensor) -> Tensor:
    ...

@overload
def index_add(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, source: Tensor) -> Tensor:
    ...

@overload
def index_copy(input: Tensor, dim: _int, index: Tensor, source: Tensor) -> Tensor:
    ...

@overload
def index_copy(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, source: Tensor) -> Tensor:
    ...

@overload
def index_fill(input: Tensor, dim: _int, index: Tensor, value: Number) -> Tensor:
    ...

@overload
def index_fill(input: Tensor, dim: _int, index: Tensor, value: Tensor) -> Tensor:
    ...

@overload
def index_fill(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, value: Number) -> Tensor:
    ...

@overload
def index_fill(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, value: Tensor) -> Tensor:
    ...

def index_put(input: Tensor, indices: Optional[Union[Tuple[Tensor, ...], List[Tensor]]], values: Tensor, accumulate: _bool = ...) -> Tensor:
    ...

def index_put_(input: Tensor, indices: Optional[Union[Tuple[Tensor, ...], List[Tensor]]], values: Tensor, accumulate: _bool = ...) -> Tensor:
    ...

@overload
def index_select(input: Tensor, dim: _int, index: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def index_select(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def init_num_threads() -> None:
    ...

def instance_norm(input: Tensor, weight: Optional[Tensor], bias: Optional[Tensor], running_mean: Optional[Tensor], running_var: Optional[Tensor], use_input_stats: _bool, momentum: _float, eps: _float, cudnn_enabled: _bool) -> Tensor:
    ...

def int_repr(input: Tensor) -> Tensor:
    ...

def inverse(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def irfft(input: Tensor, signal_ndim: _int, normalized: _bool = ..., onesided: _bool = ..., signal_sizes: _size = ...) -> Tensor:
    ...

def is_complex(input: Tensor) -> _bool:
    ...

def is_distributed(input: Tensor) -> _bool:
    ...

def is_floating_point(input: Tensor) -> _bool:
    ...

def is_grad_enabled() -> _bool:
    ...

def is_nonzero(input: Tensor) -> _bool:
    ...

def is_same_size(input: Tensor, other: Tensor) -> _bool:
    ...

def is_signed(input: Tensor) -> _bool:
    ...

def is_vulkan_available() -> _bool:
    ...

def isclose(input: Tensor, other: Tensor, rtol: _float = ..., atol: _float = ..., equal_nan: _bool = ...) -> Tensor:
    ...

def isfinite(input: Tensor) -> Tensor:
    ...

def isinf(input: Tensor) -> Tensor:
    ...

def isnan(input: Tensor) -> Tensor:
    ...

def isneginf(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def isposinf(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def isreal(input: Tensor) -> Tensor:
    ...

@overload
def kaiser_window(window_length: _int, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def kaiser_window(window_length: _int, periodic: _bool, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def kaiser_window(window_length: _int, periodic: _bool, beta: _float, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def kthvalue(input: Tensor, k: _int, dim: _int = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def kthvalue(input: Tensor, k: _int, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

def layer_norm(input: Tensor, normalized_shape: _size, weight: Optional[Tensor] = ..., bias: Optional[Tensor] = ..., eps: _float = ..., cudnn_enable: _bool = ...) -> Tensor:
    ...

def lcm(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def lcm_(input: Tensor, other: Tensor) -> Tensor:
    ...

@overload
def le(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def le(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def lerp(input: Tensor, end: Tensor, weight: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def lerp(input: Tensor, end: Tensor, weight: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def less(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def less(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def less_equal(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def less_equal(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def lgamma(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def linspace(start: Number, end: Number, steps: Optional[_int] = ..., *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def log(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def log10(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def log10_(input: Tensor) -> Tensor:
    ...

def log1p(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def log1p_(input: Tensor) -> Tensor:
    ...

def log2(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def log2_(input: Tensor) -> Tensor:
    ...

def log_(input: Tensor) -> Tensor:
    ...

@overload
def log_softmax(input: Tensor, dim: _int, dtype: Optional[_dtype] = ...) -> Tensor:
    ...

@overload
def log_softmax(input: Tensor, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ...) -> Tensor:
    ...

def logaddexp(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def logaddexp2(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def logcumsumexp(input: Tensor, dim: _int, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def logcumsumexp(input: Tensor, dim: Union[str, ellipsis, None], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def logdet(input: Tensor) -> Tensor:
    ...

def logical_and(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def logical_not(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def logical_or(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def logical_xor(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def logit(input: Tensor, eps: Optional[_float] = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def logit_(input: Tensor, eps: Optional[_float] = ...) -> Tensor:
    ...

def logspace(start: Number, end: Number, steps: Optional[_int] = ..., base: _float = ..., *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def logsumexp(input: Tensor, dim: Union[_int, _size], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def logsumexp(input: Tensor, dim: Sequence[Union[str, ellipsis, None]], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def lstm(input: Tensor, hx: Union[Tuple[Tensor, ...], List[Tensor]], params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool, batch_first: _bool) -> Tuple[Tensor, Tensor, Tensor]:
    ...

@overload
def lstm(data: Tensor, batch_sizes: Tensor, hx: Union[Tuple[Tensor, ...], List[Tensor]], params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool) -> Tuple[Tensor, Tensor, Tensor]:
    ...

def lstm_cell(input: Tensor, hx: Union[Tuple[Tensor, ...], List[Tensor]], w_ih: Tensor, w_hh: Tensor, b_ih: Optional[Tensor] = ..., b_hh: Optional[Tensor] = ...) -> Tuple[Tensor, Tensor]:
    ...

def lstsq(input: Tensor, A: Tensor, *, out: Optional[Tensor] = ...) -> namedtuple_solution_QR:
    ...

@overload
def lt(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def lt(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def lu_solve(input: Tensor, LU_data: Tensor, LU_pivots: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def masked_fill(input: Tensor, mask: Tensor, value: Number) -> Tensor:
    ...

@overload
def masked_fill(input: Tensor, mask: Tensor, value: Tensor) -> Tensor:
    ...

def masked_scatter(input: Tensor, mask: Tensor, source: Tensor) -> Tensor:
    ...

def masked_select(input: Tensor, mask: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def matmul(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def matrix_exp(input: Tensor) -> Tensor:
    ...

def matrix_power(input: Tensor, n: _int) -> Tensor:
    ...

@overload
def matrix_rank(input: Tensor, tol: _float, symmetric: _bool = ...) -> Tensor:
    ...

@overload
def matrix_rank(input: Tensor, symmetric: _bool = ...) -> Tensor:
    ...

@overload
def max(input: Tensor, dim: _int, keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def max(input: Tensor, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def max(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def max(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def max_pool1d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tensor:
    ...

def max_pool1d_with_indices(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tuple[Tensor, Tensor]:
    ...

def max_pool2d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tensor:
    ...

def max_pool3d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tensor:
    ...

def maximum(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def mean(input: Tensor, *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def mean(input: Tensor, dim: Union[_int, _size], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def mean(input: Tensor, dim: Sequence[Union[str, ellipsis, None]], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def median(input: Tensor, dim: _int, keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def median(input: Tensor, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def median(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def min(input: Tensor, dim: _int, keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def min(input: Tensor, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def min(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def min(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def minimum(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def miopen_batch_norm(input: Tensor, weight: Tensor, bias: Optional[Tensor], running_mean: Optional[Tensor], running_var: Optional[Tensor], training: _bool, exponential_average_factor: _float, epsilon: _float) -> Tuple[Tensor, Tensor, Tensor]:
    ...

def miopen_convolution(input: Tensor, weight: Tensor, bias: Optional[Tensor], padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool) -> Tensor:
    ...

def miopen_convolution_transpose(input: Tensor, weight: Tensor, bias: Optional[Tensor], padding: _size, output_padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool) -> Tensor:
    ...

def miopen_depthwise_convolution(input: Tensor, weight: Tensor, bias: Optional[Tensor], padding: _size, stride: _size, dilation: _size, groups: _int, benchmark: _bool, deterministic: _bool) -> Tensor:
    ...

def miopen_rnn(input: Tensor, weight: Union[Tuple[Tensor, ...], List[Tensor]], weight_stride0: _int, hx: Tensor, cx: Optional[Tensor], mode: _int, hidden_size: _int, num_layers: _int, batch_first: _bool, dropout: _float, train: _bool, bidirectional: _bool, batch_sizes: _size, dropout_state: Optional[Tensor]) -> Tuple[Tensor, Tensor, Tensor, Tensor, Tensor]:
    ...

def mkldnn_adaptive_avg_pool2d(input: Tensor, output_size: Union[_int, _size]) -> Tensor:
    ...

def mkldnn_convolution(input: Tensor, weight: Tensor, bias: Optional[Tensor], padding: _size, stride: _size, dilation: _size, groups: _int) -> Tensor:
    ...

def mkldnn_convolution_backward_weights(weight_size: _size, grad_output: Tensor, input: Tensor, padding: _size, stride: _size, dilation: _size, groups: _int, bias_defined: _bool) -> Tuple[Tensor, Tensor]:
    ...

def mkldnn_max_pool2d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tensor:
    ...

def mkldnn_max_pool3d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tensor:
    ...

def mm(input: Tensor, mat2: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def mode(input: Tensor, dim: _int = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def mode(input: Tensor, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def movedim(input: Tensor, source: _size, destination: _size) -> Tensor:
    ...

@overload
def movedim(input: Tensor, source: _int, destination: _int) -> Tensor:
    ...

def mul(input: Union[Tensor, Number], other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def multinomial(input: Tensor, num_samples: _int, replacement: _bool = ..., *, generator: Optional[Generator] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def multiply(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def multiply(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def mv(input: Tensor, vec: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def mvlgamma(input: Tensor, p: _int) -> Tensor:
    ...

@overload
def nanquantile(input: Tensor, q: _float, dim: Optional[_int] = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def nanquantile(input: Tensor, q: Tensor, dim: Optional[_int] = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def nansum(input: Tensor, *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def nansum(input: Tensor, dim: Union[_int, _size], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def narrow(input: Tensor, dim: _int, start: _int, length: _int) -> Tensor:
    ...

@overload
def narrow(input: Tensor, dim: _int, start: Tensor, length: _int) -> Tensor:
    ...

def native_batch_norm(input: Tensor, weight: Optional[Tensor], bias: Optional[Tensor], running_mean: Optional[Tensor], running_var: Optional[Tensor], training: _bool, momentum: _float, eps: _float, *, out: Optional[Tensor] = ...) -> Tuple[Tensor, Tensor, Tensor]:
    ...

def native_group_norm(input: Tensor, weight: Optional[Tensor], bias: Optional[Tensor], N: _int, C: _int, HxW: _int, group: _int, eps: _float) -> Tuple[Tensor, Tensor, Tensor]:
    ...

def native_layer_norm(input: Tensor, weight: Optional[Tensor], bias: Optional[Tensor], M: _int, N: _int, eps: _float) -> Tuple[Tensor, Tensor, Tensor]:
    ...

@overload
def native_norm(input: Tensor, p: Number = ...) -> Tensor:
    ...

@overload
def native_norm(input: Tensor, p: Optional[Number], dim: Union[_int, _size], keepdim: _bool, dtype: Optional[_dtype]) -> Tensor:
    ...

@overload
def ne(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def ne(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def neg(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def neg_(input: Tensor) -> Tensor:
    ...

def negative(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def negative_(input: Tensor) -> Tensor:
    ...

def nextafter(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def nonzero(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def nonzero(input: Tensor, *, as_tuple: bool = ...) -> Tensor:
    ...

def norm_except_dim(v: Tensor, pow: _int = ..., dim: _int = ...) -> Tensor:
    ...

@overload
def normal(mean: Tensor, std: _float = ..., *, generator: Optional[Generator] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def normal(mean: _float, std: Tensor, *, generator: Optional[Generator] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def normal(mean: Tensor, std: Tensor, *, generator: Optional[Generator] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def normal(mean: _float, std: _float, size: _size, *, generator: Optional[Generator] = ..., out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def not_equal(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def not_equal(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def nuclear_norm(input: Tensor, keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def nuclear_norm(input: Tensor, dim: Union[_int, _size], keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def numel(self: Tensor) -> _int:
    ...

@overload
def ones(size: _size, *, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def ones(*size: _int, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def ones(size: _size, *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def ones(*size: _int, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def ones_like(input: Tensor, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def orgqr(input: Tensor, input2: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def ormqr(input: Tensor, input2: Tensor, input3: Tensor, left: _bool = ..., transpose: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def outer(input: Tensor, vec2: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def pairwise_distance(x1: Tensor, x2: Tensor, p: _float = ..., eps: _float = ..., keepdim: _bool = ...) -> Tensor:
    ...

def pdist(input: Tensor, p: _float = ...) -> Tensor:
    ...

def pinverse(input: Tensor, rcond: _float = ...) -> Tensor:
    ...

def pixel_shuffle(input: Tensor, upscale_factor: _int) -> Tensor:
    ...

def poisson(input: Tensor, generator: Optional[Generator] = ...) -> Tensor:
    ...

def poisson_nll_loss(input: Tensor, target: Tensor, log_input: _bool, full: _bool, eps: _float, reduction: _int) -> Tensor:
    ...

def polar(abs: Tensor, angle: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def polygamma(n: _int, input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def pow(input: Tensor, exponent: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def pow(self: Number, exponent: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def pow(input: Tensor, exponent: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def prelu(input: Tensor, weight: Tensor) -> Tensor:
    ...

@overload
def prod(input: Tensor, *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def prod(input: Tensor, dim: _int, keepdim: _bool = ..., *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def prod(input: Tensor, dim: Union[str, ellipsis, None], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

def promote_types(type1: _dtype, type2: _dtype) -> _dtype:
    ...

def q_per_channel_axis(input: Tensor) -> _int:
    ...

def q_per_channel_scales(input: Tensor) -> Tensor:
    ...

def q_per_channel_zero_points(input: Tensor) -> Tensor:
    ...

def q_scale(input: Tensor) -> _float:
    ...

def q_zero_point(input: Tensor) -> _int:
    ...

def qr(input: Tensor, some: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_Q_R:
    ...

@overload
def quantile(input: Tensor, q: _float, dim: Optional[_int] = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def quantile(input: Tensor, q: Tensor, dim: Optional[_int] = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def quantize_per_channel(input: Tensor, scales: Tensor, zero_points: Tensor, axis: _int, dtype: _dtype) -> Tensor:
    ...

@overload
def quantize_per_tensor(input: Tensor, scale: _float, zero_point: _int, dtype: _dtype) -> Tensor:
    ...

@overload
def quantize_per_tensor(tensors: Union[Tuple[Tensor, ...], List[Tensor]], scales: Tensor, zero_points: Tensor, dtype: _dtype) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def quantized_batch_norm(input: Tensor, weight: Optional[Tensor], bias: Optional[Tensor], mean: Tensor, var: Tensor, eps: _float, output_scale: _float, output_zero_point: _int) -> Tensor:
    ...

def quantized_gru_cell(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Number, scale_hh: Number, zero_point_ih: Number, zero_point_hh: Number) -> Tensor:
    ...

def quantized_lstm_cell(input: Tensor, hx: Union[Tuple[Tensor, ...], List[Tensor]], w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Number, scale_hh: Number, zero_point_ih: Number, zero_point_hh: Number) -> Tuple[Tensor, Tensor]:
    ...

def quantized_max_pool1d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tensor:
    ...

def quantized_max_pool2d(input: Tensor, kernel_size: Union[_int, _size], stride: Union[_int, _size] = ..., padding: Union[_int, _size] = ..., dilation: Union[_int, _size] = ..., ceil_mode: _bool = ...) -> Tensor:
    ...

def quantized_rnn_relu_cell(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Number, scale_hh: Number, zero_point_ih: Number, zero_point_hh: Number) -> Tensor:
    ...

def quantized_rnn_tanh_cell(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Tensor, b_hh: Tensor, packed_ih: Tensor, packed_hh: Tensor, col_offsets_ih: Tensor, col_offsets_hh: Tensor, scale_ih: Number, scale_hh: Number, zero_point_ih: Number, zero_point_hh: Number) -> Tensor:
    ...

def rad2deg(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def rad2deg_(input: Tensor) -> Tensor:
    ...

@overload
def rand(size: _size, *, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def rand(*size: _int, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def rand(size: _size, *, generator: Optional[Generator], names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def rand(*size: _int, generator: Optional[Generator], names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def rand(size: _size, *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def rand(*size: _int, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def rand(size: _size, *, generator: Optional[Generator], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def rand(*size: _int, generator: Optional[Generator], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def rand_like(input: Tensor, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randint(low: _int, high: _int, size: _size, *, generator: Optional[Generator] = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randint(high: _int, size: _size, *, generator: Optional[Generator] = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randint_like(input: Tensor, high: _int, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randint_like(input: Tensor, low: _int, high: _int, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(size: _size, *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(*size: _int, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(size: _size, *, generator: Optional[Generator], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(*size: _int, generator: Optional[Generator], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(size: _size, *, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(*size: _int, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(size: _size, *, generator: Optional[Generator], names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randn(*size: _int, generator: Optional[Generator], names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def randn_like(input: Tensor, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randperm(n: _int, *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def randperm(n: _int, *, generator: Optional[Generator], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def range(start: Number, end: Number, step: Number = ..., *, out: Optional[Tensor] = ..., dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def real(input: Tensor) -> Tensor:
    ...

def reciprocal(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def reciprocal_(input: Tensor) -> Tensor:
    ...

def relu(input: Tensor) -> Tensor:
    ...

def relu_(input: Tensor) -> Tensor:
    ...

@overload
def remainder(input: Tensor, other: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def remainder(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def renorm(input: Tensor, p: Number, dim: _int, maxnorm: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def repeat_interleave(repeats: Tensor) -> Tensor:
    ...

@overload
def repeat_interleave(input: Tensor, repeats: Tensor, dim: Optional[_int] = ...) -> Tensor:
    ...

@overload
def repeat_interleave(input: Tensor, repeats: _int, dim: Optional[_int] = ...) -> Tensor:
    ...

def reshape(input: Tensor, shape: _size) -> Tensor:
    ...

def resize_as_(input: Tensor, the_template: Tensor, *, memory_format: Optional[memory_format] = ...) -> Tensor:
    ...

@overload
def result_type(tensor: Tensor, other: Tensor) -> _dtype:
    ...

@overload
def result_type(tensor: Tensor, other: Number) -> _dtype:
    ...

@overload
def result_type(scalar: Number, tensor: Tensor) -> _dtype:
    ...

@overload
def result_type(scalar1: Number, scalar2: Number) -> _dtype:
    ...

def rfft(input: Tensor, signal_ndim: _int, normalized: _bool = ..., onesided: _bool = ...) -> Tensor:
    ...

@overload
def rnn_relu(input: Tensor, hx: Tensor, params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool, batch_first: _bool) -> Tuple[Tensor, Tensor]:
    ...

@overload
def rnn_relu(data: Tensor, batch_sizes: Tensor, hx: Tensor, params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool) -> Tuple[Tensor, Tensor]:
    ...

def rnn_relu_cell(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Optional[Tensor] = ..., b_hh: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def rnn_tanh(input: Tensor, hx: Tensor, params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool, batch_first: _bool) -> Tuple[Tensor, Tensor]:
    ...

@overload
def rnn_tanh(data: Tensor, batch_sizes: Tensor, hx: Tensor, params: Union[Tuple[Tensor, ...], List[Tensor]], has_biases: _bool, num_layers: _int, dropout: _float, train: _bool, bidirectional: _bool) -> Tuple[Tensor, Tensor]:
    ...

def rnn_tanh_cell(input: Tensor, hx: Tensor, w_ih: Tensor, w_hh: Tensor, b_ih: Optional[Tensor] = ..., b_hh: Optional[Tensor] = ...) -> Tensor:
    ...

def roll(input: Tensor, shifts: Union[_int, _size], dims: Union[_int, _size] = ...) -> Tensor:
    ...

def rot90(input: Tensor, k: _int = ..., dims: _size = ...) -> Tensor:
    ...

def round(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def round_(input: Tensor) -> Tensor:
    ...

def rrelu(input: Tensor, lower: Number = ..., upper: Number = ..., training: _bool = ..., generator: Optional[Generator] = ...) -> Tensor:
    ...

def rrelu_(input: Tensor, lower: Number = ..., upper: Number = ..., training: _bool = ..., generator: Optional[Generator] = ...) -> Tensor:
    ...

def rsqrt(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def rsqrt_(input: Tensor) -> Tensor:
    ...

@overload
def rsub(input: Tensor, other: Tensor, *, alpha: Number = ...) -> Tensor:
    ...

@overload
def rsub(input: Tensor, other: Number, alpha: Number = ...) -> Tensor:
    ...

def scalar_tensor(s: Number, *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def scatter(input: Tensor, dim: _int, index: Tensor, src: Tensor) -> Tensor:
    ...

@overload
def scatter(input: Tensor, dim: _int, index: Tensor, value: Number) -> Tensor:
    ...

@overload
def scatter(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, src: Tensor) -> Tensor:
    ...

@overload
def scatter(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, value: Number) -> Tensor:
    ...

@overload
def scatter_add(input: Tensor, dim: _int, index: Tensor, src: Tensor) -> Tensor:
    ...

@overload
def scatter_add(input: Tensor, dim: Union[str, ellipsis, None], index: Tensor, src: Tensor) -> Tensor:
    ...

@overload
def searchsorted(sorted_sequence: Tensor, input: Tensor, *, out_int32: _bool = ..., right: _bool = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def searchsorted(sorted_sequence: Tensor, self: Number, *, out_int32: _bool = ..., right: _bool = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def select(input: Tensor, dim: Union[str, ellipsis, None], index: _int) -> Tensor:
    ...

@overload
def select(input: Tensor, dim: _int, index: _int) -> Tensor:
    ...

def selu(input: Tensor) -> Tensor:
    ...

def selu_(input: Tensor) -> Tensor:
    ...

def set_flush_denormal(mode: _bool) -> _bool:
    ...

def set_num_interop_threads(num: _int) -> None:
    ...

def set_num_threads(num: _int) -> None:
    ...

def sgn(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def sigmoid(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def sigmoid_(input: Tensor) -> Tensor:
    ...

def sign(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def signbit(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def sin(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def sin_(input: Tensor) -> Tensor:
    ...

def sinh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def sinh_(input: Tensor) -> Tensor:
    ...

def slogdet(input: Tensor) -> namedtuple_sign_logabsdet:
    ...

def smm(input: Tensor, mat2: Tensor) -> Tensor:
    ...

@overload
def softmax(input: Tensor, dim: _int, dtype: Optional[_dtype] = ...) -> Tensor:
    ...

@overload
def softmax(input: Tensor, dim: Union[str, ellipsis, None], *, dtype: Optional[_dtype] = ...) -> Tensor:
    ...

def solve(input: Tensor, A: Tensor, *, out: Optional[Tensor] = ...) -> namedtuple_solution_LU:
    ...

@overload
def sort(input: Tensor, dim: _int = ..., descending: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

@overload
def sort(input: Tensor, dim: Union[str, ellipsis, None], descending: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

def sparse_coo_tensor(indices: Tensor, values: Union[Tensor, List], size: Optional[_size] = ..., *, dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def split_with_sizes(input: Tensor, split_sizes: _size, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def sqrt(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def sqrt_(input: Tensor) -> Tensor:
    ...

def square(input: Tensor) -> Tensor:
    ...

def square_(input: Tensor) -> Tensor:
    ...

@overload
def squeeze(input: Tensor) -> Tensor:
    ...

@overload
def squeeze(input: Tensor, dim: _int) -> Tensor:
    ...

@overload
def squeeze(input: Tensor, dim: Union[str, ellipsis, None]) -> Tensor:
    ...

@overload
def sspaddmm(input: Tensor, mat1: Tensor, mat2: Tensor, *, beta: Number = ..., alpha: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def sspaddmm(beta: Number, self: Tensor, alpha: Number, mat1: Tensor, mat2: Tensor) -> Tensor:
    ...

@overload
def sspaddmm(beta: Number, self: Tensor, mat1: Tensor, mat2: Tensor) -> Tensor:
    ...

def stack(tensors: Union[Tuple[Tensor, ...], List[Tensor]], dim: _int = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def std(input: Tensor, unbiased: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def std(input: Tensor, dim: Union[_int, _size], unbiased: _bool = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def std(input: Tensor, dim: Sequence[Union[str, ellipsis, None]], unbiased: _bool = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def std_mean(input: Tensor, unbiased: _bool = ...) -> Tuple[Tensor, Tensor]:
    ...

@overload
def std_mean(input: Tensor, dim: Union[_int, _size], unbiased: _bool = ..., keepdim: _bool = ...) -> Tuple[Tensor, Tensor]:
    ...

@overload
def std_mean(input: Tensor, dim: Sequence[Union[str, ellipsis, None]], unbiased: _bool = ..., keepdim: _bool = ...) -> Tuple[Tensor, Tensor]:
    ...

@overload
def sub(input: Union[Tensor, Number], other: Union[Tensor, Number], *, alpha: Optional[Number] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def sub(self: Tensor, alpha: Number, other: Tensor) -> Tensor:
    ...

@overload
def sub(self: Tensor, alpha: Number, other: Tensor, *, out: Tensor) -> Tensor:
    ...

@overload
def subtract(input: Tensor, other: Tensor, *, alpha: Number = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def subtract(input: Tensor, other: Number, alpha: Number = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def sum(input: Tensor, *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def sum(input: Tensor, dim: Union[_int, _size], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def sum(input: Tensor, dim: Sequence[Union[str, ellipsis, None]], keepdim: _bool = ..., *, dtype: Optional[_dtype] = ..., out: Optional[Tensor] = ...) -> Tensor:
    ...

def svd(input: Tensor, some: _bool = ..., compute_uv: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_U_S_V:
    ...

def symeig(input: Tensor, eigenvectors: _bool = ..., upper: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_eigenvalues_eigenvectors:
    ...

def t(input: Tensor) -> Tensor:
    ...

def take(input: Tensor, index: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def tan(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def tan_(input: Tensor) -> Tensor:
    ...

def tanh(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def tanh_(input: Tensor) -> Tensor:
    ...

def tensor(data: Any, dtype: Optional[_dtype] = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def threshold(input: Tensor, threshold: Number, value: Number, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def threshold_(input: Tensor, threshold: Number, value: Number) -> Tensor:
    ...

def topk(input: Tensor, k: _int, dim: _int = ..., largest: _bool = ..., sorted: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_values_indices:
    ...

def trace(input: Tensor) -> Tensor:
    ...

@overload
def transpose(input: Tensor, dim0: _int, dim1: _int) -> Tensor:
    ...

@overload
def transpose(input: Tensor, dim0: Union[str, ellipsis, None], dim1: Union[str, ellipsis, None]) -> Tensor:
    ...

@overload
def trapz(y: Tensor, x: Tensor, *, dim: _int = ...) -> Tensor:
    ...

@overload
def trapz(y: Tensor, *, dx: _float = ..., dim: _int = ...) -> Tensor:
    ...

def triangular_solve(input: Tensor, A: Tensor, upper: _bool = ..., transpose: _bool = ..., unitriangular: _bool = ..., *, out: Optional[Tensor] = ...) -> namedtuple_solution_cloned_coefficient:
    ...

def tril(input: Tensor, diagonal: _int = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def tril_indices(row: _int, col: _int, offset: _int = ..., *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def triu(input: Tensor, diagonal: _int = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def triu_indices(row: _int, col: _int, offset: _int = ..., *, dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def true_divide(input: Union[Tensor, Number], other: Union[Tensor, Number], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def trunc(input: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def trunc_(input: Tensor) -> Tensor:
    ...

@overload
def unbind(input: Tensor, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

@overload
def unbind(input: Tensor, dim: Union[str, ellipsis, None]) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def unique_dim(input: Tensor, dim: _int, sorted: _bool = ..., return_inverse: _bool = ..., return_counts: _bool = ...) -> Tuple[Tensor, Tensor, Tensor]:
    ...

def unsafe_chunk(input: Tensor, chunks: _int, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def unsafe_split(input: Tensor, split_size: _int, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def unsafe_split_with_sizes(input: Tensor, split_sizes: _size, dim: _int = ...) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def unsqueeze(input: Tensor, dim: _int) -> Tensor:
    ...

def vander(x: Tensor, N: Optional[_int] = ..., increasing: _bool = ...) -> Tensor:
    ...

@overload
def var(input: Tensor, unbiased: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def var(input: Tensor, dim: Union[_int, _size], unbiased: _bool = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def var(input: Tensor, dim: Sequence[Union[str, ellipsis, None]], unbiased: _bool = ..., keepdim: _bool = ..., *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def var_mean(input: Tensor, unbiased: _bool = ...) -> Tuple[Tensor, Tensor]:
    ...

@overload
def var_mean(input: Tensor, dim: Union[_int, _size], unbiased: _bool = ..., keepdim: _bool = ...) -> Tuple[Tensor, Tensor]:
    ...

@overload
def var_mean(input: Tensor, dim: Sequence[Union[str, ellipsis, None]], unbiased: _bool = ..., keepdim: _bool = ...) -> Tuple[Tensor, Tensor]:
    ...

def vdot(input: Tensor, other: Tensor, *, out: Optional[Tensor] = ...) -> Tensor:
    ...

def view_as_complex(input: Tensor) -> Tensor:
    ...

def view_as_real(input: Tensor) -> Tensor:
    ...

def vstack(tensors: Union[Tuple[Tensor, ...], List[Tensor]], *, out: Optional[Tensor] = ...) -> Tensor:
    ...

@overload
def where(condition: Tensor, input: Tensor, other: Tensor) -> Tensor:
    ...

@overload
def where(condition: Tensor, self: Number, other: Tensor) -> Tensor:
    ...

@overload
def where(condition: Tensor, input: Tensor, other: Number) -> Tensor:
    ...

@overload
def where(condition: Tensor, self: Number, other: Number) -> Tensor:
    ...

@overload
def where(condition: Tensor) -> Union[Tuple[Tensor, ...], List[Tensor]]:
    ...

def zero_(input: Tensor) -> Tensor:
    ...

@overload
def zeros(size: _size, *, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def zeros(*size: _int, names: Optional[Sequence[Union[str, ellipsis, None]]], out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def zeros(size: _size, *, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

@overload
def zeros(*size: _int, out: Optional[Tensor] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

def zeros_like(input: Tensor, *, memory_format: Optional[memory_format] = ..., dtype: _dtype = ..., layout: _layout = ..., device: Union[_device, str, None] = ..., requires_grad: _bool = ...) -> Tensor:
    ...

