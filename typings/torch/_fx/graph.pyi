"""
This type stub file was generated by pyright.
"""

import torch
from .node import Argument, Node, Target
from typing import Any, Callable, Dict, List, Optional, Tuple

def snake_case(s: str) -> str:
    ...

def map_arg(a: Argument, fn: Callable[[Node], Argument]) -> Argument:
    """ apply fn to each Node appearing arg. arg may be a list, tuple, slice, or dict with string keys. """
    ...

class Graph:
    def __init__(self) -> None:
        ...
    
    @property
    def nodes(self):
        ...
    
    def graph_copy(self, g: Graph):
        """
        Append all nodes from graph `g` to this graph
        """
        ...
    
    def create_node(self, op: str, target: Target, args: Optional[Tuple[Argument, ...]] = ..., kwargs: Optional[Dict[str, Argument]] = ..., name: Optional[str] = ...) -> Node:
        ...
    
    def placeholder(self, name: str) -> Node:
        ...
    
    def get_attr(self, name: str) -> Node:
        ...
    
    def call_module(self, module_name: str, args: Optional[Tuple[Argument, ...]] = ..., kwargs: Optional[Dict[str, Argument]] = ...) -> Node:
        ...
    
    def call_method(self, method_name: str, args: Optional[Tuple[Argument, ...]] = ..., kwargs: Optional[Dict[str, Argument]] = ...) -> Node:
        ...
    
    def call_function(self, the_function: Callable[..., Any], args: Optional[Tuple[Argument, ...]] = ..., kwargs: Optional[Dict[str, Argument]] = ...) -> Node:
        ...
    
    def node_copy(self, node: Node, arg_transform: Callable[[Node], Argument] = ...) -> Node:
        """ copy a node from one graph into another. arg_transform needs to transform arguments from the graph of node
            to the graph of self. Example:

            g : torch._fx.Graph = ...
            new_graph = torch._fx.graph()
            value_remap = {}
            for node in g.nodes:
                value_remap[node] = new_graph.node_copy(node, lambda n : value_remap[n])
        """
        ...
    
    def output(self, result: Argument):
        ...
    
    def python_code(self, root_module: str) -> Tuple[str, str, List[str]]:
        ...
    
    def __str__(self) -> str:
        ...
    
    def lint(self, root: Optional[torch.nn.Module] = ...):
        """
        Runs various checks on this Graph to make sure it is well-formed. In
        particular:
            - Checks Nodes have correct ownership (owned by this graph)
            - Checks Nodes appear in topological order
            - If `root` is provided, checks that `target`s exist in `root`
        """
        ...
    


reflectable_magic_methods = { 'add': '{} + {}','sub': '{} - {}','mul': '{} * {}','floordiv': '{} // {}','truediv': '{} / {}','div': '{} / {}','mod': '{} % {}','pow': '{} ** {}','lshift': '{} << {}','rshift': '{} >> {}','and': '{} & {}','or': '{} | {}','xor': '{} ^ {}','getitem': '{}[{}]' }
magic_methods = dict({ 'eq': '{} == {}','ne': '{} != {}','lt': '{} < {}','gt': '{} > {}','le': '{} <= {}','ge': '{} >= {}','pos': '+{}','neg': '-{}','invert': '~{}' }, **reflectable_magic_methods)
