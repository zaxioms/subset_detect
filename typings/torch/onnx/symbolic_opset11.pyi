"""
This type stub file was generated by pyright.
"""

from torch.onnx.symbolic_helper import parse_args
from torch.nn.modules.utils import _pair, _single, _triple

@parse_args('v', 'f', 'f')
def hardtanh(g, self, min_val, max_val):
    ...

def clamp(g, self, min, max):
    ...

def clamp_min(g, self, min):
    ...

def clamp_max(g, self, max):
    ...

@parse_args('v', 'i', 'v')
def select(g, self, dim, index):
    ...

def index_put(g, self, indices_list_value, values, accumulate=...):
    ...

@parse_args('v', 'i')
def pixel_shuffle(g, self, upscale_factor):
    ...

upsample_nearest1d = _interpolate('upsample_nearest1d', 3, "nearest")
upsample_nearest2d = _interpolate('upsample_nearest2d', 4, "nearest")
upsample_nearest3d = _interpolate('upsample_nearest3d', 5, "nearest")
upsample_linear1d = _interpolate('upsample_linear1d', 3, "linear")
upsample_bilinear2d = _interpolate('upsample_bilinear2d', 4, "linear")
upsample_trilinear3d = _interpolate('upsample_trilinear3d', 5, "linear")
upsample_bicubic2d = _interpolate('upsample_bicubic2d', 4, "cubic")
@parse_args('v', 'i', 'v', 'v')
def gather(g, self, dim, index, sparse_grad=...):
    ...

@parse_args('v', 'i', 'v', 'v')
def scatter(g, self, dim, index, src):
    ...

@parse_args('v', 'i', 'none')
def cumsum(g, self, dim, dtype=...):
    ...

def masked_select(g, self, mask):
    ...

def masked_scatter(g, self, mask, source):
    ...

def append(g, self, tensor):
    ...

def add(g, self, other, alpha=...):
    ...

def insert(g, self, pos, tensor):
    ...

def pop(g, tensor_list, dim):
    ...

def cat(g, tensor_list, dim):
    ...

def stack(g, tensor_list, dim):
    ...

avg_pool1d = _avg_pool('avg_pool1d', _single)
avg_pool2d = _avg_pool('avg_pool2d', _pair)
avg_pool3d = _avg_pool('avg_pool3d', _triple)
@parse_args('v', 'i', 'i', 'i', 'i')
def unique_dim(g, self, dim, sorted, return_inverse, return_counts):
    ...

@parse_args('v', 'v', 'i', 'i', 'i', 'none')
def topk(g, self, k, dim, largest, sorted, out=...):
    ...

@parse_args('v', 'i', 'i', 'none')
def sort(g, self, dim, decending, out=...):
    ...

def round(g, self):
    ...

@parse_args('v', 'v', 'i', 'i')
def split(g, self, split_size_or_sizes, dim, _outputs=...):
    ...

@parse_args('v', 'v', 'i', 'i')
def split_with_sizes(g, self, split_sizes, dim, _outputs=...):
    ...

@parse_args('v', 'i', 'i')
def unbind(g, self, dim=..., _outputs=...):
    ...

def constant_pad_nd(g, input, padding, value=...):
    ...

def reflection_pad(g, input, padding):
    ...

def replication_pad(g, input, padding):
    ...

reflection_pad1d = reflection_pad
reflection_pad2d = reflection_pad
reflection_pad3d = reflection_pad
replication_pad1d = replication_pad
replication_pad2d = replication_pad
replication_pad3d = replication_pad
def det(g, self):
    ...

def logdet(g, input):
    ...

def arange(g, *args):
    ...

def size(g, self, dim=...):
    ...

def squeeze(g, self, dim=...):
    ...

@parse_args('v', 'i')
def unsqueeze(g, self, dim):
    ...

def mm(g, self, other):
    ...

def index_fill(g, self, dim, index, value):
    ...

def index_copy(g, self, dim, index, source):
    ...

@parse_args('v', 'is', 'is', 'is', 'is')
def im2col(g, input, kernel_size, dilation, padding, stride):
    ...

def narrow(g, input, dim, start, length):
    ...

@parse_args('v', 'i', 'i')
def flatten(g, input, start_dim, end_dim):
    ...

@parse_args('v', 'v', 'v', 'i', 'i', 'i', 'v', 'i')
def embedding_bag(g, embedding_matrix, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset):
    ...

