"""
This type stub file was generated by pyright.
"""

import pickle
import types
from typing import Any, Callable, Dict, Optional

class PackageImporter:
    """Importers allow you to load code written to packages by PackageExporter.
    Code is loaded in a hermetic way, using files from the package
    rather than the normal python import system. This allows
    for the packaging of PyTorch model code and data so that it can be run
    on a server or used in the future for transfer learning.

    The importer for packages ensures that code in the module can only be loaded from
    within the package, except for modules explicitly listed as external during export.
    The file `extern_modules` in the zip archive lists all the modules that a package externally depends on.
    This prevents "implicit" dependencies where the package runs locally because it is importing
    a locally-installed package, but then fails when the package is copied to another machine.
    """
    modules: Dict[str, Optional[types.ModuleType]]
    def __init__(self, filename: str, module_allowed: Callable[[str], bool] = ...) -> None:
        """Open `filename` for importing. This checks that the imported package only requires modules
        allowed by `module_allowed`

        Args:
            filename (str): archive to load. Can also be a directory of the unzipped files in the archive
                for easy debugging and editing.
            module_allowed (Callable[[str], bool], optional): A method to determine if a externally provided module
                should be allowed. Can be used to ensure packages loaded do not depend on modules that the server
                does not support. Defaults to allowing anything.

        Raises:
            ImportError: If the package will use a disallowed module.
        """
        ...
    
    def import_module(self, name: str, package=...):
        """Load a module from the package if it hasn't already been loaded, and then return
        the module. Modules are loaded locally
        to the importer and will appear in `self.modules` rather than `sys.modules`

        Args:
            name (str): Fully qualified name of the module to load.
            package ([type], optional): Unused, but present to match the signature of importlib.import_module. Defaults to None.

        Returns:
            types.ModuleType: the (possibly already) loaded module.
        """
        ...
    
    def load_binary(self, package: str, resource: str) -> bytes:
        """Load raw bytes.

        Args:
            package (str): The name of module package (e.g. "my_package.my_subpackage")
            resource (str): The unique name for the resource.

        Returns:
            bytes: The loaded data.
        """
        ...
    
    def load_text(self, package: str, resource: str, encoding: str = ..., errors: str = ...) -> str:
        """Load a string.

        Args:
            package (str): The name of module package (e.g. "my_package.my_subpackage")
            resource (str): The unique name for the resource.
            encoding (str, optional): Passed to `decode`. Defaults to 'utf-8'.
            errors (str, optional): Passed to `decode`. Defaults to 'strict'.

        Returns:
            str: The loaded text.
        """
        ...
    
    def load_pickle(self, package: str, resource: str, map_location=...) -> Any:
        """Unpickles the resource from the package, loading any modules that are needed to construct the objects
        using :meth:`import_module`

        Args:
            package (str): The name of module package (e.g. "my_package.my_subpackage")
            resource (str): The unique name for the resource.
            map_location: Passed to `torch.load` to determine how tensors are mapped to devices. Defaults to None.

        Returns:
            Any: the unpickled object.
        """
        ...
    
    def get_source(self, module_name) -> str:
        ...
    
    def __import__(self, name, globals=..., locals=..., fromlist=..., level=...):
        ...
    


_NEEDS_LOADING = object()
_ERR_MSG_PREFIX = 'No module named '
_ERR_MSG = _ERR_MSG_PREFIX + '{!r}'
class _UnpicklerWrapper(pickle._Unpickler):
    def __init__(self, importer, *args, **kwargs) -> None:
        ...
    
    def find_class(self, module, name):
        ...
    


class _PathNode:
    ...


class _PackageNode(_PathNode):
    def __init__(self, source_file: Optional[str]) -> None:
        ...
    


class _ModuleNode(_PathNode):
    __slots__ = ...
    def __init__(self, source_file: str) -> None:
        ...
    


class _ExternNode(_PathNode):
    ...


