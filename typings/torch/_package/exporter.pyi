"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, List

class PackageExporter:
    """ Exporters allow you to write packages of code, pickled python data, and
    arbitrary binary and text resources into a self-contained package.

    Imports can load this code in a hermetic way, such that code is loaded
    from the package rather than the normal python import system. This allows
    for the packaging of PyTorch model code and data so that it can be run
    on a server or used in the future for transfer learning.

    The code contained in packages is copied file-by-file from the original
    source when it is created, and the file format is a specially organized
    zip file. Future users of the package can unzip the package, and edit the code
    in order to perform custom modifications to it.

    The importer for packages ensures that code in the module can only be loaded from
    within the package, except for modules explicitly listed as external using :method:`extern_module`.
    The file `extern_modules` in the zip archive lists all the modules that a package externally depends on.
    This prevents "implicit" dependencies where the package runs locally because it is importing
    a locally-installed package, but then fails when the package is copied to another machine.


    Dependencies
    ------------

    When source code is added to the package, the exporter optionally can scan it
    for further code dependencies (`dependencies=True`). It looks for import statements,
    resolves relative references to qualified module names, and calls :method:`require_module`
    on each it finds, recursively resolving dependencies.

    """
    importers: List[Callable[[str], Any]]
    def __init__(self, filename: str, verbose: bool = ...) -> None:
        """
        Create an exporter.

        Args:
            filename: e.g. my_package.zip
            verbose: Print information about dependency resolution to stdout.
                Useful for tracking down why certain files get included.
        """
        ...
    
    def save_source_file(self, module_name: str, file_or_directory: str, dependencies=...):
        """Adds the local file system `file_or_directory` to the source package to provide the code
        for `module_name`.

        Args:
            module_name (str): e.g. `my_package.my_subpackage`, code will be saved to provide code for this package.
            file_or_directory (str): the path to a file or directory of code. When a directory, all python files in the directory
                are recursively copied using :meth:`save_source_file`. If a file is named "/__init__.py" the code is treated
                as a package.
            dependencies (bool, optional): If True, we scan the source for dependencies (see :ref:`Dependencies`).
        """
        ...
    
    def save_source_string(self, module_name: str, src: str, is_package: bool = ..., dependencies: bool = ..., orig_file_name: str = ...):
        """Adds `src` as the source code for `module_name` in the exported package.

        Args:
            module_name (str): e.g. `my_package.my_subpackage`, code will be saved to provide code for this package.
            src (str): The python source code to save for this package
            is_package (bool, optional): If True, this module is treated as a package. Packages are allowed to have submodules
                (e.g. my_package.my_subpackage.my_subsubpackage), and resources can be saved inside them. Defaults to False.
            dependencies (bool, optional): If True, we scan the source for dependencies (see :ref:`Dependencies`).
            orig_file_name (str, optional): If present, used in logging to identifying where the source came from. Defaults to None.
        """
        ...
    
    def require_module_if_not_provided(self, module_name: str, dependencies=...):
        ...
    
    def require_module(self, module_name: str, dependencies=...):
        """This is called by dependencies resolution when it finds that something in the package
        depends on the module and it is not already present. It then decides how to provide that module.
        The default resolution rules will mark the module as extern if it is part of the standard library,
        and call `save_module` otherwise. Clients can subclass this object
        and override this method to provide other behavior, such as automatically mocking out a whole class
        of modules"""
        ...
    
    def save_module(self, module_name: str, dependencies=...):
        """Save the code for `module_name` into the package. Code for the module is resolved using the `importers` path to find the
        module object, and then using its `__file__` attribute to find the source code.
        Args:
            module_name (str): e.g. `my_package.my_subpackage`, code will be saved to provide code for this package.
            dependencies (bool, optional): If True, we scan the source for dependencies (see :ref:`Dependencies`).
        """
        ...
    
    def save_pickle(self, package: str, resource: str, obj: Any, dependencies: bool = ...):
        """Save a python object to the archive using pickle. Equivalent to :func:`torch.save` but saving into
        the archive rather than a stand-alone file. Stanard pickle does not save the code, only the objects.
        If `dependencies` is true, this method will also scan the pickled objects for which modules are required
        to reconstruct them and save the relevant code.

        To be able to save an object where `type(obj).__name__` is `my_module.MyObject`,
        `my_module.MyObject` must resolve to the class of the object according to the `importer` order. When saving objects that
        have previously been packaged, the importer's `import_module` method will need to be present in the `importer` list
        for this to work.

        Args:
            package (str): The name of module package this resource should go it (e.g. "my_package.my_subpackage")
            resource (str): A unique name for the resource, used to indentify it to load.
            obj (Any): The object to save, must be picklable.
            dependencies (bool, optional): If True, we scan the source for dependencies (see :ref:`Dependencies`).
        """
        ...
    
    def save_text(self, package: str, resource: str, text: str):
        """Save text data to the package

        Args:
            package (str): The name of module package this resource should go it (e.g. "my_package.my_subpackage")
            resource (str): A unique name for the resource, used to indentify it to load.
            text (str): The contents to save
        """
        ...
    
    def save_binary(self, package, resource, binary: bytes):
        """Save raw bytes to the package.

        Args:
            package (str): The name of module package this resource should go it (e.g. "my_package.my_subpackage")
            resource (str): A unique name for the resource, used to indentify it to load.
            binary (str): The data to save.
        """
        ...
    
    def extern_module(self, module_name: str):
        """Include `module` in the list of external modules the package can import.
        This will prevent dependency discover from saving
        it in the package. The importer will load an external module directly from the standard import system.
        Code for extern modules must also exist in the process loading the package.

        Args:
            module_name (str): e.g. "my_package.my_subpackage" the name of the external module
        """
        ...
    
    def extern_modules(self, module_names: List[str]):
        """Extern a list of modules. Convience wrapper for calling :meth:`extern_module` on many items.

        Args:
            module_names (List[str]): List of module names
        """
        ...
    
    def mock_module(self, module_name: str):
        """Replace the code for `module_name` in the package with a fake implementation. This module will return a fake
        object for any attribute accessed from it. Because we copy file-by-file, the dependency resolution will sometimes
        find files that are imported by model files but whose functionality is never used
        (e.g. custom serialization code or training helpers).
        Use this function to mock this functionality out without having to modify the original code.

        Args:
            module_name (str): e.g. "my_package.my_subpackage" the name of the module to be mocked out.
        """
        ...
    
    def mock_modules(self, module_names):
        """Mock a list of modules. Convience wrapper for calling :meth:`mock_module` on many items.

        Args:
            module_names (List[str]): List of module names
        """
        ...
    
    def __enter__(self):
        ...
    
    def __exit__(self, type, value, traceback):
        ...
    
    def close(self):
        """Write the package to the filesystem. Any calls after close are now invalid.
        It is preferable to use resource guard syntax instead:

            with PackageExporter("file.zip") as e:
                ...
        """
        ...
    


_DISALLOWED_MODULES = ['sys', 'io']
_MOCK_IMPL = """\
from _mock import MockedObject
def __getattr__(attr: str):
    return MockedObject(__name__ + '.' + attr)
"""
